I"V<p class="notice--warning">인프런에 있는 홍정모 교수님의 <strong>홍정모의 따라 하며 배우는 C++</strong> 강의를 듣고 정리한 필기입니다. 😀  <br />
<a href="https://www.inflearn.com/course/following-c-plus">🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!</a></p>

<p><br /></p>

<h1 id="chapter-8-객체-지향의-기초--클래스와-const">chapter 8. 객체 지향의 기초 : 클래스와 const</h1>

<h2 id="-const-가-붙은-객체">🔔 const 가 붙은 객체</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">Friend</span> <span class="n">f</span><span class="p">;</span>

<span class="n">f</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 💥에러! 불가능</span>
<span class="n">f</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 💥에러! 불가능 </span>
</code></pre></div></div>
<ul>
  <li>객체 선언시 <code class="language-plaintext highlighter-rouge">const</code>가 붙는 것의 의미
    <ul>
      <li>Friend 타입의 객체 <em>f</em>의 <strong><u>멤버의 값을 바꿀 수 없다.</u></strong>
        <ul>
          <li>따라서 setter 접근 함수 사용이 불가능 해진다.</li>
          <li>근데 의외로 getter는 멤버의 값을 바꾸지 않는데도 불구하고   <u>getter 접근 함수의 사용도 불가능</u>해진다.
            <ul>
              <li>멤버를 바꾸지 않는 것을 확실히 하는 <strong>const 멤버 함수만 사용 가능하기 때문!</strong></li>
              <li>컴파일러는 멤버 값을 바꿨는가 아닌가로 판단하는 것이 아닌 멤버 함수가 const인가 아닌가로 판단한다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="뒤에-const가-붙은-멤버-함수만-사용-가능">뒤에 const가 붙은 멤버 함수만 사용 가능</h3>

<blockquote>
  <p>객체를 생성할 때 const를 붙이면 멤버 값을 변경하는게 불가능하다. 그리고 이 객체는 const가 붙은 멤버 함수만 사용할 수 있다.</p>
</blockquote>

<blockquote>
  <p>뒤에 <code class="language-plaintext highlighter-rouge">const</code>가 붙을 수 있는건 <u>멤버 함수만 가능하다.</u> 일반 전역 함수는 뒤에 <code class="language-plaintext highlighter-rouge">const</code>를 붙일 수 없다.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">Friend</span> <span class="n">f</span><span class="p">;</span>

<span class="n">f</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 💥에러! 불가능</span>
<span class="n">f</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// ⭐이제 가능⭐</span>
</code></pre></div></div>

<p>멤버 함수 이름 <strong>뒤에</strong> <code class="language-plaintext highlighter-rouge">const</code>를 붙여 <u>멤버 값을 변경하지 않을 것이라는걸 확실히 해준다.</u> 객체가 <code class="language-plaintext highlighter-rouge">const</code>로 생성되었을시 <code class="language-plaintext highlighter-rouge">const</code>가 붙은 멤버 함수만 사용할 수 있다. setter 함수는 그 자체로 멤버의 값을 변경하는 함수기 때문에 const 멤버 함수로 만들 수 없다. const 붙여도 오류가 난다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">const</code>가 붙지 않은 일반 객체도 <code class="language-plaintext highlighter-rouge">const</code>멤버 함수를 호출할 수 있다. (호출 못 할거라고 착각했었다 😥) 단, <code class="language-plaintext highlighter-rouge">const</code>가 붙은 객체는 <code class="language-plaintext highlighter-rouge">const</code>멤버 함수<strong>만</strong> 호출할 수 있다.</li>
  <li>매개 변수가 <code class="language-plaintext highlighter-rouge">const</code> 객체인 함수들은 인수로 받은 해당 객체의 멤버 함수를 사용할 때 꼭 뒤에 const가 붙은 함수만 사용할 수 있게 된다.
    <ul>
      <li>함수에 인수로 객체를 넘길 때, 그 안에서 사용될 일이 있는 멤버 함수라면 뒤에 <code class="language-plaintext highlighter-rouge">const</code>를 붙여주어야 한다.</li>
      <li><u>getter 같은 접근 함수는 많이 사용되고 또한 멤버 값을 변경하지 않기 때문에 그냥 뒤에 const를 붙여서 구현해주자.</u></li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h2 id="-복사-생성자">🔔 복사 생성자</h2>

<p>📜Something 클래스</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Something</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Something</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
    
	<span class="kt">void</span> <span class="n">setValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">int</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>📜main</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">Something</span> <span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">st</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">m_value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Something</span> <span class="n">something</span><span class="p">;</span>
	
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">something</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">print</span><span class="p">(</span><span class="n">something</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

Constructor
0x7fff7fbdd2fc  // &amp;st 와
0x7fff7fbdd2dc  // &amp;something 은 주소가 다르다.
0
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">print(something)</code>이 호출하면서 print 함수의 매개변수 <em>st</em> 에 메인 함수에서 생성된 <em>something</em> 객체가 복사된다.
    <ul>
      <li>매개 변수이자 지역 변수인 <em>Something st</em>도 Something 객체로서 생성된다.</li>
      <li>Something 객체가 2번 생성되니 생성자도 2번 호출되야 한다.
        <ol>
          <li>Something something; (메인 함수)</li>
          <li>Something st = something; (print 함수의 매개변수)</li>
        </ol>
      </li>
      <li>그러나 “Constructor”가 1번 출력되는 것을 보니 <u>생성자가 한번만 호출됐다는 것을 알 수 있다.</u>
        <ul>
          <li>이유는 매개 변수에 복사되는 <em>Something st = something</em> 이 실행될 때 클래스에 디폴트로 숨겨져 있던 <code class="language-plaintext highlighter-rouge">복사 생성자</code>가 호출되었기 때문이다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Something</span> <span class="p">(</span><span class="k">const</span> <span class="n">Something</span> <span class="o">&amp;</span> <span class="n">st_in</span><span class="p">)</span> <span class="c1">// 복사 생성자</span>
<span class="p">{</span>
    <span class="n">m_value</span> <span class="o">=</span> <span class="n">st_in</span><span class="p">.</span><span class="n">m_value</span><span class="p">;</span> <span class="c1">// 멤버 복사</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><em>Something st = something;</em>
    <ul>
      <li>Call by Value 형태로 <em>something</em> 을 전달한다.</li>
      <li>매개 변수인 <em>Something st</em> 객체가 생성되면서 복사 하는 같은 타입의 대상이 있기에 복사 생성자가 호출된다.</li>
      <li><em>st_in</em> 은 복사 없이 <em>something</em> 그 자체를 참조한다. (Call by Reference)</li>
      <li><em>st_in.m_value</em>, 즉 <em>something</em> 객체의 <em>m_value</em> 멤버 값을</li>
      <li><em>st</em> 객체의 멤버 <em>m_value</em> 에 대입(복사)한다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>클래스는 모두 <u>const</u>이자 <u>같은 타입의 객체</u>를 <u>참조</u>로 인수 1개를 받아 그 멤버들의 값을 내 멤버들에 복사하는 <code class="language-plaintext highlighter-rouge">복사생성자</code>를 디폴트로 가지고 있다. 숨겨져서 안보일 뿐!</p>
</blockquote>

<ul>
  <li>즉 객체가 생성될 때 <u>같은 타입의 객체의 멤버를 복사하여 멤버를 초기화</u>한다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">const</code>
        <ul>
          <li>복사하는 대상인 객체의 멤버 값을 변경할 수 없다.</li>
          <li>복사하는 대상인 객체의 const 멤버 함수에만 접근이 가능하다.</li>
        </ul>
      </li>
      <li>같은 타입의 객체 그 자체(참조)를 가져와 <u>복사</u>한다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>디폴트로 있긴 하지만 아래 코드와 같이 프로그래머가 직접 복사생성자를 정의할 수도 있다.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Something</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Something</span><span class="p">(</span><span class="k">const</span> <span class="n">Something</span><span class="o">&amp;</span> <span class="n">st_in</span><span class="p">)</span>  <span class="c1">// 복사 생성자를 직접 정의했다.</span>
	<span class="p">{</span>
		<span class="n">m_value</span> <span class="o">=</span> <span class="n">st_in</span><span class="p">.</span><span class="n">m_value</span><span class="p">;</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Something</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
    
	<span class="kt">void</span> <span class="n">setValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">int</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">Something</span> <span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">st</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">m_value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Something</span> <span class="n">something</span><span class="p">;</span>
	
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">something</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">print</span><span class="p">(</span><span class="n">something</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

Constructor
0x7ffd1a921798  

Copy constructor                  
0x7ffd1a92179c  

0
</code></pre></div></div>
<p>복사 생성자가 호출되는 것을 확인할 수 있다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">Something</span> <span class="o">&amp;</span> <span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">st</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">m_value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위와 같이 매개변수 타입을 바꿔주면 <em>Something</em>이 <em>st</em>에 복사되는 것이 아닌 <em>st</em> 가 <em>Something</em> 객체 그 자체를 참조하게 되므로 복사 생성자가 호출되지 않는다. 복사 과정이 없으므로!</p>

<h3 id="복사-생성자가-호출될-때">복사 생성자가 호출될 때</h3>
<ol>
  <li>먼저 생성한 객체를 나중에 생성한 객체의 생성자 인자로 전달할 때</li>
  <li>함수의 인자로 객체를 Call by Value 형태로 전달할 때</li>
  <li>객체를 Call by Value 형태로 리턴할 때</li>
</ol>

<p><br /></p>

<h2 id="-const-함수의-오버로딩">🔔 const 함수의 오버로딩</h2>

<blockquote>
  <p>만약 동일한 함수가 2개 있는데 <u>하나는 const를 붙이고</u> <u>하나는 const를 붙이지 않았다면</u> 어떻게 오버로딩이 될까?</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
</span>
<span class="k">class</span> <span class="nc">Something</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">m_value</span> <span class="o">=</span> <span class="s">"default"</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"const version"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">string</span> <span class="o">&amp;</span> <span class="n">getValue</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"non-const version"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Something</span> <span class="n">s1</span><span class="p">;</span>
    <span class="n">s1</span><span class="p">.</span><span class="n">getValue</span><span class="p">();</span>   <span class="c1">// string &amp; getValue() 호출</span>

    <span class="k">const</span> <span class="n">Something</span> <span class="n">s2</span><span class="p">;</span>
    <span class="n">s2</span><span class="p">.</span><span class="n">getValue</span><span class="p">();</span>  <span class="c1">// const string &amp; getValue() const 호출</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span>
</code></pre></div></div>
<ul>
  <li>리턴 타입 : <code class="language-plaintext highlighter-rouge">const string &amp;</code>
    <ul>
      <li>리턴 되는 <em>m_value</em> 의 레퍼런스를 리턴한다.
        <ul>
          <li>임시 공간에 복사 하는 과정 없이 그대로 리턴한다.</li>
        </ul>
      </li>
      <li><u>const 레퍼런스</u> 이므로 리턴 되는 string 값을 수정할 수 없다.
        <ul>
          <li><em>s2.getValue() = 20</em> 불가능.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>뒤에 <code class="language-plaintext highlighter-rouge">const</code>가 붙었으므로
    <ul>
      <li>멤버 값을 변경할 수 없으며</li>
      <li><code class="language-plaintext highlighter-rouge">const</code>객체의 경우 이 함수만 호출할 수 있다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>const 의 유무도 오버로딩의 고려 대상이 된다.</p>
</blockquote>

<ul>
  <li>일반 객체로 생성된 <em>s1</em>은
    <ul>
      <li>*s1.getValue() 호출시</li>
      <li><em>string &amp; getValue()</em> 를 오버로딩한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">const 객체</code>로 생성된 <em>s2</em>은
    <ul>
      <li>*s2.getValue() 호출시</li>
      <li><em>const string &amp; getValue() <u>const</u></em> 를 오버로딩한다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">const 객체</code>는 <strong>뒤에</strong> const가 붙은 함수를 오버로딩 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>보통 멤버 함수를 <code class="language-plaintext highlighter-rouge">const</code>로 만들 땐 리턴 타입도 <code class="language-plaintext highlighter-rouge">const</code>로 한다. <em><u>const</u> string &amp; getValue() <u>const</u></em></p>
</blockquote>

<ul>
  <li>const가 앞에 붙은 함수
    <ul>
      <li>단순히 <u>리턴</u>을 변경할 수 없는 <u>상수로</u> 하겠다는 의미</li>
    </ul>
  </li>
  <li>const가 뒤에 붙은 함수
    <ul>
      <li>const 객체만 사용할 수 있는 함수로서</li>
      <li><u>멤버 값을 변경하지 않겠다</u>는 의미</li>
    </ul>
  </li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>

<p><br /></p>
:ET