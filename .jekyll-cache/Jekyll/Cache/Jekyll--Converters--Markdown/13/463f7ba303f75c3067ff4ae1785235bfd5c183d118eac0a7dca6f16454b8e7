I"^<p class="notice--warning">인프런에 있는 홍정모 교수님의 <strong>홍정모의 따라 하며 배우는 C++</strong> 강의를 듣고 정리한 필기입니다. 😀  <br />
<a href="https://www.inflearn.com/course/following-c-plus">🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!</a></p>

<p><br /></p>

<h1 id="chapter-7-함수--다양한-리턴-값">chapter 7. 함수 : 다양한 리턴 값</h1>

<h2 id="1-값을-리턴">1. 값을 리턴</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">getValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">getValue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>getValue(3)
    <ul>
      <li>함수가 호출되고 인수 <code class="language-plaintext highlighter-rouge">3</code>이 넘어가면서 <code class="language-plaintext highlighter-rouge">int</code> getValue 함수의 매개변수인 <code class="language-plaintext highlighter-rouge">int x</code>에 3이 복사된다.
        <ul>
          <li>내부적으로 <code class="language-plaintext highlighter-rouge">int x = 3</code> 과정이 이루어짐</li>
          <li>getValue 함수의 지역변수인 <code class="language-plaintext highlighter-rouge">value</code> (값 6)가 리턴된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>int value = getValue(3);
    <ul>
      <li>getValue의 리턴값인 <code class="language-plaintext highlighter-rouge">value</code>의 값이 <code class="language-plaintext highlighter-rouge">main의 value</code>에 <u>복사</u>된다.</li>
      <li>그리고 getValue가 역할을 다하고 끝내면서 <u>지역변수인 value도 메모리에서 사라진다.</u></li>
    </ul>
  </li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">int</code> 리턴 + <code class="language-plaintext highlighter-rouge">int value = getValue(3);</code>
    <ul>
      <li>리턴을 이렇게 <u>값</u>으로 하면 대규모로 진행할시 느려질 수 있다.
        <ul>
          <li><u>복사가 많아지니까!</u></li>
          <li>구조체, 클래스, 배열 사용시에는 비효율적인 방법이다.</li>
        </ul>
      </li>
      <li>변수 하나를 리턴하는 경우라면 값을 리턴하는 것이 효율적이고 안전하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="2-주소를-리턴">2. 주소를 리턴</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="nf">allocateMemory</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="n">allocatememory</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>

    <span class="k">delete</span> <span class="p">[]</span> <span class="n">array</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>allocatememory(1024)
    <ul>
      <li>함수가 호출되고 인수 <code class="language-plaintext highlighter-rouge">1024</code>가 넘어가면서 <code class="language-plaintext highlighter-rouge">int *</code> allocateMemory 함수의 매개변수인 <code class="language-plaintext highlighter-rouge">int size</code>에 1024가 복사된다.
        <ul>
          <li>내부적으로 <code class="language-plaintext highlighter-rouge">int size = 1024</code> 과정이 이루어짐</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>int * array = allocatememory(1024);
    <ul>
      <li>allocatememory의 리턴값인 <code class="language-plaintext highlighter-rouge">new int[size]</code>의 값이 <code class="language-plaintext highlighter-rouge">main의 int * array</code>에 대입된다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">new</code>는 동적 할당 메모리의 주소값을 리턴하므로 주소값이 <code class="language-plaintext highlighter-rouge">main의 int * array</code>에 대입된다.</li>
          <li><code class="language-plaintext highlighter-rouge">new</code>는 힙메모리에서 동적 할당 받기 때문에 함수 범위가 끝나도 사라지지 않는다. 동적 할당 메모리는 프로그래머가 직접 <code class="language-plaintext highlighter-rouge">delete</code>로 반납하기 전까지는 계속 살아있음.</li>
        </ul>
      </li>
    </ul>
    <ul>
      <li>함수 호출이 끝나고 리턴이 다 끝나도 <code class="language-plaintext highlighter-rouge">new</code>로 동적 할당 받은 힙 메모리는 유지됨</li>
      <li>지역 변수인 size만 사라짐</li>
    </ul>
  </li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="nf">getValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">value_1</span> <span class="o">=</span> <span class="n">getValue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">value_2</span> <span class="o">=</span> <span class="o">*</span><span class="n">getValue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">return &amp;value;</code> : 이렇게 주소값 리터럴 (<u>R-value</u>)로 리턴하는 경우</p>
<ul>
  <li><u>value는 지역변수이므로 리턴 후 메모리가 해제되고 사라지기 때문에 이미 사라진 곳의 주소를 넘기게 되는 것일 수 있어 위험할 수 있다.</u> 사라진 메모리의 주소를 복사받는 것이니까.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">int * value_1 = getValue(3);</code>
        <ul>
          <li>메모리가 사라진 값의 주소를 받음</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">int value_2 = *getValue(3);</code>
        <ul>
          <li>메모리가 사라진 값의 주소를 간접참조함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>따라서 포인터를 리턴할시 위와 같이 코드를 짜는것은 지양하자.</li>
  <li>int * array = allocatememory(1024); 같은 경우는 동적 할당 받아 사라지지 않는 힙메모리를 사용한 것이니 함수가 끝나면서 사라질 위험이 없기 때문에 안전한 것.</li>
  <li>이처럼 함수 내에서 선언된 <u>지역변수를 반환하는 경우에는 ***주소 리턴***을 받지 말자.</u> 위험함.</li>
</ul>

<p><br /></p>

<h2 id="3-참조를-리턴">3. 참조를 리턴</h2>

<h3 id="그냥-int-로-int--참조-리턴을-대입-받는-경우">그냥 int 로 int &amp; 참조 리턴을 대입 받는 경우</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">getValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// value의 참조를 리턴</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">getValue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>getValue(3)
    <ul>
      <li>함수가 호출되고 인수 <code class="language-plaintext highlighter-rouge">3</code>이 넘어가면서 <code class="language-plaintext highlighter-rouge">int</code> getValue 함수의 매개변수인 <code class="language-plaintext highlighter-rouge">int x</code>에 3이 복사된다.
        <ul>
          <li>내부적으로 <code class="language-plaintext highlighter-rouge">int x = 3</code> 과정이 이루어짐</li>
          <li>getValue 함수의 지역변수인 <code class="language-plaintext highlighter-rouge">value</code> (값 6)가 리턴된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>int value = getValue(3);
    <ul>
      <li><code class="language-plaintext highlighter-rouge">main의 value</code>는 <code class="language-plaintext highlighter-rouge">int &amp; getValue</code>에서 리턴한 <code class="language-plaintext highlighter-rouge">value</code>가 참조하는 메모리를 <u>복사</u> 받게 된다!
        <ul>
          <li><code class="language-plaintext highlighter-rouge">int &amp; value</code>가 아닌 <code class="language-plaintext highlighter-rouge">그냥 int value</code>로 함수 리턴값을 대입 받아서 참조가 아닌 그냥 리턴값을 <u>복사</u>한게 되는 것.</li>
          <li>이 함수는 리턴타입이 <code class="language-plaintext highlighter-rouge">int &amp;</code>이 되므로 <u>value에 대한 참조를 리턴한다.</u></li>
        </ul>
      </li>
    </ul>
    <ul>
      <li><u>그냥 int</u>, 즉 값으로 리턴하면 <code class="language-plaintext highlighter-rouge">return value</code>더라도 value의 값, 즉 <code class="language-plaintext highlighter-rouge">R-value</code>로서 리턴을 하게 되는데</li>
      <li><u>int &amp;</u>, 즉 참조로 리턴하면 <code class="language-plaintext highlighter-rouge">L-value</code>로서 리턴을 하게 된다. 
      - 그러나 getValue가 역할을 다하고 끝내면서 <u>지역변수이자 참조 변수인 value가 참조하는 메모라 공간은 잠깐 있다 사라진다.</u>
      - <code class="language-plaintext highlighter-rouge">main의 value</code>는 <u>없어진 공간을 복사 받은 셈이 되는 것이다</u></li>
      <li>그래서 실행하면 <em>warning: reference to local variable ‘value’ returned [-Wreturn-local-add]</em> 같은 경고메세지가 뜸.</li>
    </ul>
  </li>
</ol>

<h3 id="int--참조-변수로-int--참조-리턴을-대입-받는-경우">int &amp; 참조 변수로 int &amp; 참조 리턴을 대입 받는 경우</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">getValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// value의 참조를 리턴</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">getValue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 6으로 잘 나온다.</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 쓰레기 값이 나온다.</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">int &amp; value = getValue(3);</code></p>
<ul>
  <li>getValue 함수의 지역변수 value의 메모리 공간을 참조 변수 <code class="language-plaintext highlighter-rouge">int &amp;</code>인 value가 참조하게 된다.</li>
  <li>함수가 종료되며 지역 변수인 value 메모리 공간은 파괴된다.</li>
  <li>그러나 !! <code class="language-plaintext highlighter-rouge">main의 int &amp; 변수인 value</code>는 계속해서 이 파괴되어 쓰레기 값 들어있는 공간을 참조한다.
    <ul>
      <li>따라서 한번 더  value를 출력하려하면 쓰레기값이 나오는 것.  사라져버려서 ㅠ ㅠ</li>
    </ul>
  </li>
  <li>이처럼 함수 내에서 선언된 <u>지역변수를 반환하는 경우에는 ***참조 리턴***을 받지 말자.</u> 위험함. 주소 리턴과 마찬가지로 !</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">my_array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ix</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">my_array</span><span class="p">[</span><span class="n">ix</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="o">&gt;</span> <span class="n">my_array</span><span class="p">;</span>
    <span class="n">my_array</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">get</span><span class="p">(</span><span class="n">my_array</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="c1">// my_array[30] = 1024 과 동일</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><u>인수를 기존에 main에서 메모리를 잡고 있는 상태인 배열의 참조로 넘긴 상태.</u> std::array&lt;int, 100&gt; <code class="language-plaintext highlighter-rouge">&amp;</code> my_array
    <ul>
      <li>따라서 <code class="language-plaintext highlighter-rouge">get 내의 지역변수 my_array</code>는 함수가 끝나고 사라져도 공간은 사라지지 않고 계속 존재하기 때문에 <u>기존 공간을 참조 매개변수에게 넘기고 이를 리턴받을 경우엔 위험할 일이 없다.</u></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">get(my_array, 30) = 1024;</code>
    <ul>
      <li>참조로 리턴했기 때문에, 즉 L-value로서 리턴했기 때문에 변수에 값을 저장하는 것 처럼 보인다.
        <ul>
          <li>my_array[30] = 1024 과 동일</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="정리">정리</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">int 값</code> 리턴 : <u>임시 변수</u>에 리턴된 객체를 <u>복사</u>한 후 그 임시 변수를 <u>R-value 속성</u>으로 리턴한다.
    <ul>
      <li>즉, 해당 객체가 아닌 주소가 다른 임시 변수의 메모리가 리턴 된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">int &amp; 참조</code> 리턴 : 임시 변수에 복사하는 과정 없이 그 객체를 레퍼런스, 즉 실제 객체 그 자체를 <u>L-value 속성</u>으로 리턴한다.
    <ul>
      <li>리턴하는게 단순 함수 내의 지역변수라면 소멸 시점을 주의하여야 한다.</li>
    </ul>
    <ul>
      <li>함수가 소멸되면서 지역변수도 소멸되는데 지역 변수를 참조로 리턴 받은 바깥 변수는 여전히 소멸된 지역변수 메모리 자리를 참조하고 있는 것이 되기 때문이다.</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h2 id="4-구조체를-리턴">4. 구조체를 리턴</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">S</span>
<span class="p">{</span>
  
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">S</span> <span class="nf">getStruct</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">my_s</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">my_s</span> <span class="o">=</span> <span class="n">getStruct</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">my_s</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>구조체를 리턴받아 값을 받을 경우 한번에 여러개의 값을 받을 수 있다.</li>
  <li>함수를 하나 만들 때마다 구조체 또한 또 만들어야 하는게 단점
    <ul>
      <li><code class="language-plaintext highlighter-rouge">튜플(Tuple)</code>로 극복할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="5-튜플을-리턴">5. 튜플을 리턴</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;tuple&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">getTuple</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">my_tp</span> <span class="o">=</span> <span class="n">getTuple</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">my_tp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// a. int다</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">my_tp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// b. double이다.</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>#include &lt;tuple&gt;
    <ul>
      <li>std::tuple</li>
      <li>std::make_tuple</li>
    </ul>
  </li>
  <li>튜플은 대괄호 <code class="language-plaintext highlighter-rouge">[]</code>를 쓴다.</li>
  <li>튜플을 통해 각각 자료형이 다른 두개 이상의 리턴값을 받을 수 있다.</li>
  <li>C++ 17부턴 <code class="language-plaintext highlighter-rouge">std::tuple&lt;int, double&gt; my_tp = getTuple();</code> 을 간단하게 <code class="language-plaintext highlighter-rouge">auto[a, d] = getTuple</code> 이런식으로 쓸 수 있다.</li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET