I"+<p class="notice--warning">인프런에 있는 홍정모 교수님의 <strong>홍정모의 따라 하며 배우는 C++</strong> 강의를 듣고 정리한 필기입니다. 😀  <br />
<a href="https://www.inflearn.com/course/following-c-plus">🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!</a></p>

<p><br /></p>

<h1 id="chapter-12-가상-함수들--객체-잘림과-reference_wrapper">chapter 12. 가상 함수들 : 객체 잘림과 reference_wrapper</h1>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">객체 잘림</code> : 부모에 자식을 구겨 넣을 때 발생한다.</p>
</blockquote>

<ul>
  <li>자식 타입 객체가 부모 타입 객체보다 메모리 용량이 더 크다.
    <ul>
      <li>부모 타입 객체를 포함하기 떄문에.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;functional&gt; // reference_wrapper 용
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Base"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="n">m_j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm derived"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="-부모-타입의-포인터--참조로-자식-객체-가리키기">🔔 부모 타입의 포인터 &amp; 참조로 자식 객체 가리키기</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Base</span> <span class="o">&amp;</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">derived</span><span class="p">;</span>
<span class="n">Base</span> <span class="o">*</span> <span class="n">b2</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Derived</span><span class="p">();</span>
</code></pre></div></div>

<blockquote>
  <p>부모 타입의 <u>포인터 Object *</u> 나 <u>참조 Object &amp;</u> 변수로 자식 객체를 가리킬 땐 <u>객체 잘림 없이 다형성을 실현한다</u>⭐</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">Base</span> <span class="o">&amp;</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

	<span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>  

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

I'm Derived
</code></pre></div></div>
<ul>
  <li>단순히 <code class="language-plaintext highlighter-rouge">b1</code>라는 참조 변수가 Derived 타입의 객체 <code class="language-plaintext highlighter-rouge">d</code>를 <u>가리키고 있을 뿐이기 때문에</u> 더 작은 메모리(부모)에 자식 객체를 구겨 넣어 <u>객체가 잘리는 일이 없다.</u>
    <ul>
      <li>따라서 부모 타입의 포인터나 참조 변수로 자식 객체가 오버라이딩 한 내용을 호출할 수 있으며(단, 가상 함수 일때.) 이를 <code class="language-plaintext highlighter-rouge">다형성</code>이라고 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="-부모-타입의-객체에-자식-객체-집어-넣기--객체-잘림-발생">🔔 부모 타입의 객체에 자식 객체 집어 넣기 : 객체 잘림 발생</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Base</span> <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
</code></pre></div></div>
<blockquote>
  <p>위와 같이 <u>그냥 부모 객체에 자식 객체를 우겨 넣으려고 하면</u> <u>객체 잘림 현상</u>이 발생하며 <strong>다형성을 실행할 수 없다.</strong></p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">Base</span> <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

	<span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>  

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

I'm Base
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Base b = d</code> 👉 <code class="language-plaintext highlighter-rouge">b</code>가 부모인 Base 타입이라 <code class="language-plaintext highlighter-rouge">d</code>보다 메모리 용량이 작은데 <code class="language-plaintext highlighter-rouge">d</code>를 우겨넣으려니 객체 잘림 현상이 발생한다.
    <ul>
      <li><u>Derived만의 부분들 (Derived에서 오버라이딩 한것, 상속 받은 것이 아닌 Derived만의 멤버들) 은 잘려 버리고 Base로부터 상속받은 부분들만</u> <code class="language-plaintext highlighter-rouge">b</code>에 들어가게 된다.</li>
      <li>“I’m Base” 출력
        <ul>
          <li>print()가 가상 함수고 오버라이딩이 되어있었더라도 Derived 부분들은 다 잘려나갔기 때문에 Base의 print() 호출.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">void func(Base b)</code> 이런식으로 인수를 참조나 포인터가 아닌 그냥 객체로 받는 경우, 객체 잘림 현상에 주의해야 한다. 다형성이 실행되지 않는다.</p>
</blockquote>

<p><br /></p>

<h2 id="-reference_wrapper">🔔 reference_wrapper</h2>

<blockquote>
  <p>std::reference_wrapper&lt;Base&gt;</p>
</blockquote>

<ul>
  <li>#include &lt;functional&gt;을 해주어야 사용 가능하다.</li>
  <li><u>일반 객체를 참조 형태로 리턴</u>해주는 역할을 한다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Base</span> <span class="n">b</span><span class="p">;</span>
<span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span> <span class="n">my_vec</span><span class="p">;</span>
<span class="n">my_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="n">my_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">ele</span> <span class="o">:</span> <span class="n">my_vec</span><span class="p">)</span>
    <span class="n">ele</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>
</code></pre></div></div>
<p><u>std::vector는 참조 형태의 원소는 받지 않는다.</u> 따라서 다형성을 위해 위와 같이 포인터로 넣어줄 수도 있지만</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Base</span> <span class="n">b</span><span class="p">;</span>
<span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;&gt;</span> <span class="n">my_vec</span><span class="p">;</span>
<span class="n">my_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">my_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">ele</span> <span class="o">:</span> <span class="n">my_vec</span><span class="p">)</span>
    <span class="n">ele</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">print</span><span class="p">();</span>
</code></pre></div></div>
<p>꼭 참조 형태로 넣어주고 싶다면 위와 같이 <code class="language-plaintext highlighter-rouge">reference_wrapper</code>를 사용하여 그냥 객체인 Base 타입을 참조 형태로 리턴 받아 다형성을 실현할 수 있다.</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a>
<br /></p>
:ET