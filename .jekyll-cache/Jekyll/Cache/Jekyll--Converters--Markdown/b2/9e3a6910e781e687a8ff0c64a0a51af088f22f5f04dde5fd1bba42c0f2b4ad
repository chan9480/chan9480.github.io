I"?<p class="notice--warning">인프런에 있는 홍정모 교수님의 <strong>홍정모의 따라 하며 배우는 C++</strong> 강의를 듣고 정리한 필기입니다. 😀  <br />
<a href="https://www.inflearn.com/course/following-c-plus">🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!</a></p>

<p><br /></p>

<h2 id="포인터">포인터</h2>
<p>메모리 주소를 담는 변수를 뜻한다.</p>

<p><code class="language-plaintext highlighter-rouge">&amp;</code></p>
<ul>
  <li><u>변수</u> 앞에 붙으면 그 변수의 주소</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">*</code></p>
<ul>
  <li><u>포인터 변수</u> 앞에 붙으면 그 포이터 변수가 담고 있는 주소에 담긴 데이터</li>
  <li>간접 참조</li>
</ul>

<p><br /></p>

<h2 id="포인터-변수의-선언">포인터 변수의 선언</h2>
<p>포인터 선언시 <code class="language-plaintext highlighter-rouge">가리킬 메모리의 데이터 타입 + *</code></p>

<p><em>ex) int *, double *</em></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>  
<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>  <span class="c1">// x 값이 7로 변한다. x=7 이나 마찬가지.</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">int * ptr = &amp;x;</code></p>
<ul>
  <li>int 타입의 변수의 주소를 담을 수 있는 포인터라는 의미에서 int *</li>
  <li>포인터 변수 ptr은 int형 변수인 x의 주소로 초기화 됐다.</li>
  <li><u>포인터 ptr은 x 를 가리키고 있다.</u></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">*ptr = 7;</code></p>
<ul>
  <li>ptr은 현재 x의 주소를 담고 있는데 <code class="language-plaintext highlighter-rouge">*</code>를 포인터 앞에 붙이면 x의 데이터를 참조할 수 있게 된다.</li>
  <li>동시에 x의 값이 7로 바뀐다.</li>
  <li>포인터 선언시 데이터 타입을 적어줘야 하는 이유는 이렇게 간접 참조할때 어떤 타입으로 값을 가져올지 정보가 필요하기 때문이다.</li>
</ul>

<p><br /></p>

<h2 id="포인터를-사용하는-이유">포인터를 사용하는 이유</h2>
<ul>
  <li>많은 양의 데이터를 <u>복사</u>할땐 연산 시간도 늘어나고 써야하는 메모리 공간도 늘어난다.
    <ul>
      <li>이때 그냥 포인터로 간접 참조하거나 포인터에 주소를 두고 주소 정보만 복사해서 넘기면 내용물들을 복사할 필요가 없게 되어 효율적이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="포인터의-크기">포인터의 크기</h2>

<h3 id="sizeofptr">sizeof(ptr)</h3>

<ul>
  <li>32 bit 시스템에서는 int * 이든 double *이든 크기는 4byte다.
    <ul>
      <li>32bit = 4byte. 4byte의 주소 체계를 쓰기 때문</li>
    </ul>
  </li>
  <li>64 bit 시스템에서는 int * 이든 double *이든  크기는 8byte다.
    <ul>
      <li>64bit = 8byte. 8byte의 주소 체계를 쓰기 때문</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="nullptr">nullptr</h2>
<ul>
  <li>C언어에선 <code class="language-plaintext highlighter-rouge">NULL</code>로 쓰여쓴데 C++에선 <code class="language-plaintext highlighter-rouge">nullptr</code>로 쓰임</li>
  <li>포인터(주소) 값이 없다는 의미. 즉, 가르키고 있는 대상이 현재 없음. 아무 주소도 담고 있지 않음.</li>
  <li>다른 것을 가리키고 있지 않은 포인터의 경우 nullptr로 꼭 초기화 해주는 습관을 들이자.
    <ul>
      <li>if문을 두어 포인터가 nullptr 일 경우 다른 작동을 하게끔 할 수도 있고</li>
      <li><code class="language-plaintext highlighter-rouge">double * ptr = nullptr</code> <br />
포인터도 변수기 때문에 초기화를 해주지 않으면 쓰레기 값이 들어있기 때문이다. 뜬금없이 이상한 공간을 가리키고 있을 수 있기 때문에..</li>
    </ul>
  </li>
</ul>

<h3 id="cstddef-의-stdnullptr_t">&lt;cstddef&gt; 의 <code class="language-plaintext highlighter-rouge">std::nullptr_t</code></h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span> <span class="n">nptr</span><span class="p">;</span> <span class="c1">// 변수 nptr 은 nullptr만 대입될 수 있다.</span>
</code></pre></div></div>

<p>&lt;csstddef&gt; 라이브러리는 std::nullptr_t 타입을 지원하는데 이 타입의 변수는 nullptr만 담을 수 있다.</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET