I"b<p class="notice--warning">인프런에 있는 홍정모 교수님의 <strong>홍정모의 따라 하며 배우는 C++</strong> 강의를 듣고 정리한 필기입니다. 😀  <br />
<a href="https://www.inflearn.com/course/following-c-plus">🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!</a></p>

<p><br /></p>

<h1 id="chapter-15-의미론적-이동과-스마트-포인터">chapter 15. 의미론적 이동과 스마트 포인터</h1>

<h1 id="153-이동-생성자와-이동-대입-연산자">15.3 이동 생성자와 이동 대입 연산자</h1>

<blockquote>
  <p>소유권을 박탈시켜 주지 않으면 동시에 두 포인터가 동일한 객체를 소유하게 되므로 나중에 한 포인터를 통해 메모리를 해제 시키면 문제가 생길 수 있다.</p>
</blockquote>

<blockquote>
  <p>R-value 객체를 복사, 대입할 때 대처</p>
</blockquote>

<p><br /></p>

<h2 id="-복사-생성자-대입-연산자-오버로딩">🔔 복사 생성자, 대입 연산자 오버로딩</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">const L-value reference</code>를 사용하는 <strong>복사 생성자, 대입 연산자 오버로딩</strong></p>
</blockquote>

<ul>
  <li>복사, 대입시 ⭐<u>소유권 이동, 박탈 문제를 고려해야 한다.</u>
    <ul>
      <li><strong>소유권을 이동</strong>시킬 때 새로운 빈 공간을 만든 후 ✨깊은 복사✨로 내용물들을 이동 시킨다</li>
      <li><strong>소유권 박탈</strong>은 복사 생성자 혹은 대입 연산자 호출이 끝난 후 기존 공간(복사 대상이 된 매개 변수)은 지역 변수이기 때문에 자동으로 사라지므로 수동으로 박탈해줄 필요는 없다.
        <ul>
          <li>어차피 새로운 인스턴스를 만들어 그 쪽으로 옮겨준 것이라 애초에 소유한 것이 서로 다른게 된다.</li>
          <li>따라서 깊은 복사로 내용물만 복사해서 옮겨준 것.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="resourceh">📜Resource.h</h3>

<blockquote>
  <p><strong>복사생성자</strong>와 <strong>대입 연산자</strong>로 소유권 이동, 박탈 정상 작동</p>
</blockquote>

<ul>
  <li>💙<strong>복사 생성자</strong>
    <ul>
      <li><em>Resource(res.m_length);</em>
        <ul>
          <li>복사할 대상이 되는 객체(인수)의 멤버를 생성자 인수로 넘긴다.
            <ul>
              <li>이걸로 포인터 멤버인 <code class="language-plaintext highlighter-rouge">m_data</code>에 그 크기만큼의 <u>새로운 공간을 할당</u>하고 <code class="language-plaintext highlighter-rouge">m_length</code>에 대입함</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">m_data</code>에 <u>내용물들 깊은 복사하여 이사</u>시킨다.
        <ul>
          <li><em>for문 m_data[i] = res.m_data[i];</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>💙<strong>대입 연산자 오버로딩</strong>
    <ul>
      <li><u>대입하려는게 자기 자신일 경우</u> 아무것도 하지 않고 자기 자신만 리턴
        <ul>
          <li>복사 생성자를 호출할땐 필요 없지만 대입 시엔 필요한 과정</li>
        </ul>
      </li>
      <li><u>기존 공간 비우기</u>. 메모리 누수 방지
        <ul>
          <li>복사 생성자를 호출할땐 필요 없지만 대입 시엔 필요한 과정</li>
          <li><em>if (this-&gt;m_data != nullptr) delete[] m_data;</em></li>
        </ul>
      </li>
      <li>포인터 멤버인 <code class="language-plaintext highlighter-rouge">m_data</code>에 <u>새로운 공간을 할당</u>하고 <code class="language-plaintext highlighter-rouge">m_length</code>에 대입함
        <ul>
          <li><em>m_length = res.m_length;</em></li>
          <li><em>m_data = new int[m_length];</em></li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">m_data</code>에 <u>내용물들 깊은 복사하여 이사</u>시킨다.
        <ul>
          <li><em>for문 m_data[i] = res.m_data[i];</em></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Resource</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">int</span> <span class="o">*</span> <span class="n">m_data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">m_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">public:</span>
	<span class="n">Resource</span><span class="p">()</span> <span class="c1">// 기본 생성자</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource constructed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Resource</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span> <span class="c1">// 일반 매개변수 1개 생성자</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource length constructed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">m_data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">m_length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Resource</span><span class="p">(</span><span class="k">const</span> <span class="n">Resource</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="c1">// 💎복사 생성자💎 </span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource copy constructed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		
		<span class="n">Resource</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">m_length</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>  <span class="c1">// 내용물을 전부 깊은 복사 (시간이 꽤 걸림)</span>
			<span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
 
	<span class="o">~</span><span class="n">Resource</span><span class="p">()</span>  <span class="c1">// 소멸자</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource destroyed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Resource</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="n">Resource</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span>  <span class="c1">// 💎대입 연산자 오버로딩💎</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource copy assignment"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">res</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="c1">// 대입하려는게 자기 자신이면 아무것도 안함</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_data</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">m_data</span><span class="p">;</span> <span class="c1">// 1. 내 자신의 m_data 비워주기</span>

		<span class="n">m_length</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">m_length</span><span class="p">;</span> <span class="c1">// 2. 대입으로 넘겨받은 res의 length 로 내 length 갱신</span>
		
		<span class="n">m_data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m_length</span><span class="p">];</span> <span class="c1">// 3. 비워진 내 자신의 m_data에 새로운 공간 할당받기</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// 4. m_data내용물 넣기.</span>
			<span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//  대입으로 넘겨받은 res의 m_data 내용물들을 **내 m_data**에 깊은 복사</span>

		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>   
<span class="p">};</span>
</code></pre></div></div>

<h3 id="autoptrh">📜AutoPtr.h</h3>

<ul>
  <li>템플릿 클래스이다.*
    <ul>
      <li><code class="language-plaintext highlighter-rouge">T</code>에 <strong>Resource</strong> 타입을 받아 <strong>Resource</strong>타입의 <u>스마트 포인터 역할</u>을 할 것이다.
        <ul>
          <li>Resource의 <u>대입 연산자를 호출하여 소유권을 확실히 이전</u>시킨다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>복사생성자</strong>와 <strong>대입 연산자</strong>로 소유권 이동, 박탈 정상 작동</p>
</blockquote>

<ul>
  <li>💙<strong>복사 생성자</strong>
    <ul>
      <li><em>m_ptr = new T;</em>
        <ul>
          <li><u>새로운 공간을 할당</u></li>
        </ul>
      </li>
      <li><em>*m_ptr = *a.m_ptr;</em>
        <ul>
          <li>Resource의 ‘대입 연산자 오버로딩 호출
            <ul>
              <li><code class="language-plaintext highlighter-rouge">m_data</code>에 <u>내용물들 깊은 복사하여 이사</u>시킨다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>💙<strong>대입 연산자 오버로딩</strong>
    <ul>
      <li><u>대입하려는게 자기 자신일 경우</u> 아무것도 하지 않고 자기 자신만 리턴
        <ul>
          <li>복사 생성자를 호출할땐 필요 없지만 대입 시엔 필요한 과정</li>
        </ul>
      </li>
      <li><u>기존 공간 비우기</u>. 메모리 누수 방지
        <ul>
          <li>복사 생성자를 호출할땐 필요 없지만 대입 시엔 필요한 과정</li>
          <li><em>if (m_ptr != nullptr) delete m_ptr;</em></li>
        </ul>
      </li>
      <li><em>m_ptr = new T;</em>
        <ul>
          <li><u>새로운 공간을 할당</u></li>
        </ul>
      </li>
      <li><em>*m_ptr = *a.m_ptr;</em>
        <ul>
          <li>Resource의 ‘대입 연산자 오버로딩 호출
            <ul>
              <li><code class="language-plaintext highlighter-rouge">m_data</code>에 <u>내용물들 깊은 복사하여 이사</u>시킨다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>💙<u>어차피 함수 매개변수로서 지역 변수이기 때문에 복사생성자, 대입 연산자 호출이 끝나면 매개 변수 수명도 끝나므로 자동으로 소유권 박탈이 이루어 진다.</u></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">AutoPtr</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">T</span><span class="o">*</span> <span class="n">m_ptr</span><span class="p">;</span>

<span class="nl">public:</span>
	<span class="n">AutoPtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span>
		<span class="o">:</span><span class="n">m_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AutoPtr default constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">AutoPtr</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AutoPtr destructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m_ptr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">delete</span> <span class="n">m_ptr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">AutoPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">AutoPtr</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// 💎복사 생성자💎</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AutoPtr copy constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

		<span class="c1">// deep copy</span>
		<span class="n">m_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">;</span>  <span class="c1">// T가 Resource 타입으로 들어오면 m_ptr은 Resource 타입의 포인터</span>
		<span class="o">*</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span>  <span class="c1">// ⭐Resource의 '대입 연산자 오버로딩 호출</span>
	<span class="p">}</span>
	<span class="n">AutoPtr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">AutoPtr</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// 💎대입 연산자 오버로딩💎</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AutoPtr copy assignment"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m_ptr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">delete</span> <span class="n">m_ptr</span><span class="p">;</span>

		<span class="c1">// deep copy</span>
		<span class="n">m_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">;</span>  <span class="c1">// 새로운 빈 공간 할당 받기. T가 Resource 타입으로 들어오면 m_ptr은 Resource 타입의 포인터</span>
		<span class="o">*</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="c1">// ⭐Resource의 '대입 연산자 오버로딩' 호출 </span>

		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">T</span><span class="o">*</span> <span class="k">operator</span> <span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">bool</span> <span class="n">inNull</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_ptr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="maincpp">📜main.cpp</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include "AutoPtr.h"
#include "Resource.h"
#include "Timer.h"
</span>
<span class="n">AutoPtr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">generateResource</span><span class="p">()</span>  <span class="c1">// AutoPtr&lt;Resource&gt; 타입을 리턴하는 함수</span>
<span class="p">{</span>
   <span class="c1">// 10000000 의 length를 가진 Resource타입의 멤버를 가지는 AutoPtr 객체 생성</span>
	<span class="n">AutoPtr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="k">new</span> <span class="n">Resource</span><span class="p">(</span><span class="mi">10000000</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
	<span class="n">streambuf</span> <span class="o">*</span> <span class="n">orig_buf</span> <span class="o">=</span> <span class="n">cout</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">();</span>
	<span class="c1">// cout.rdbuf(NULL); 화면에 출력되는 메세지들 끄기. 시간 어마어마하게 걸릴테니까 😎</span>

	<span class="n">Timer</span> <span class="n">timer</span><span class="p">;</span>
	<span class="p">{</span>
		<span class="n">AutoPtr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">main_res</span><span class="p">;</span> <span class="c1">// ⭐</span>
		<span class="n">main_res</span> <span class="o">=</span> <span class="n">generateResource</span><span class="p">();</span> <span class="c1">// ⭐ generateResource() 리턴값은 R-value </span>
	<span class="p">}</span>
		<span class="n">cout</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">(</span><span class="n">orig_buf</span><span class="p">);</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">timer</span><span class="p">.</span><span class="n">elapsed</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 실행시간 재서 출력</span>
	<span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

AutoPtr default constructor
Resource length constructor
AutoPtr default constructor
AutoPtr copy assignment
Resource default constructor
Resource copy assignment
AutoPtr destructor
Resource destroyed
AutoPtr destructor
Resource destroyed
0.0392126
</code></pre></div></div>

<h3 id="실행-순서">실행 순서</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">AutoPtr</code> 디폴트 생성자
    <ul>
      <li><em>AutoPtr&lt;Resource&gt; main_res;</em> 에서 호출 됨</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Resource</code> 매개변수 1개 짜리 생성자
    <ul>
      <li>generateResource() 함수 내부에서 <em>new Resource(10000000);</em> 에서 호출 됨</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">AutoPtr</code> 디폴트 생성자
    <ul>
      <li>generateResource() 함수 내부에서 <em>AutoPtr&lt;Resource&gt; res(new Resource(10000000));</em> 에서 호출 됨</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">AutoPtr</code> 대입 연산자 오버로딩
    <ul>
      <li><em>main_res = generateResource();</em> 에서 호출 됨</li>
      <li>함수의 리턴 값을 main_res에 대입하는 과정에서 호출됨</li>
      <li>대입 연산자의 매개변수 <code class="language-plaintext highlighter-rouge">a</code>는 <u>const인 L-Value Reference이기 때문에 generateResource() 함수 리턴값 같은 R-Value도 참조할 수 있다.</u></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Resource</code> 디폴트 생성자
    <ul>
      <li>4번의 AutoPtr 대입 연산자 오버로딩 내부의 <em>m_ptr = new T;</em> 에서 호출됨. <em>m_ptr = new Resource;</em> 나 마찬가지!</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Resource</code> 대입 연산자 오버로딩
    <ul>
      <li>4번의 AutoPtr 대입 연산자 오버로딩 내부의 <em>m_ptr = *a.m_ptr;</em> 에서 호출 됨</li>
    </ul>
  </li>
  <li>첫번째 <code class="language-plaintext highlighter-rouge">AutoPtr</code>, <code class="language-plaintext highlighter-rouge">Resource</code> 소멸자
    <ul>
      <li>generateResource() 실행이 종료 됨에 따른
<em>AutoPtr&lt;Resource&gt; res(new Resource(10000000));</em>
에서의 소멸</li>
    </ul>
  </li>
  <li>두번째 <code class="language-plaintext highlighter-rouge">AutoPtr</code>, <code class="language-plaintext highlighter-rouge">Resource</code> 소멸자
    <ul>
      <li>진짜 main 에서의 두 객체 소멸</li>
    </ul>
  </li>
</ol>

<p>위 결과는 “Release” 모드로 실행했을 때의 결과이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

AutoPtr default constructor
Resource length constructed
AutoPtr default constructor
AutoPtr copy constructor
Resource default constructed
Resource copy assignment
AutoPtr destructor
Resource destroyed
AutoPtr copy assignement
Resource default constructed
Resource copy assignment
AutoPtr destructor
Resource destroyed
AutoPtr destructor
Resource destroyed
</code></pre></div></div>

<blockquote>
  <p>Copy elision</p>
</blockquote>

<p>위 결과는 “Debug” 모드로 실행했을 때의 결과이다. 디버그 모드로 실행했을 땐 릴리즈 모드와 달리 generateResource() 함수의 <code class="language-plaintext highlighter-rouge">res</code> 이 리턴값이 임시 객체에 복사되는 과정에서 AutoPtr 복사 생성자(copy constructor)를 호출하는 것을 확인할 수 있다. C++ 컴파일러는 경우에 따라 최적화를 위하여 복사생성자 호출을 스킵해주는데 릴리즈 모드에선 함수 리턴값이 임시 객체에 복사되는 과정에 대해선 복사 생성자 호출을 생략해준다. <strong>Copy elision</strong></p>

<p><a href="https://stackoverflow.com/questions/33795529/does-a-return-by-value-call-the-copy-constructor-or-the-copy-assignment-operator">https://stackoverflow.com/questions/33795529/does-a-return-by-value-call-the-copy-constructor-or-the-copy-assignment-operator</a></p>

<p><br /></p>

<h2 id="-이동-생성자-이동-대입-연산자-오버로딩">🔔 이동 생성자, 이동 대입 연산자 오버로딩</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">R-value reference</code>(&amp;&amp;)를 사용하는 <strong>이동 생성자, 이동 대입 연산자 오버로딩</strong>. <code class="language-plaintext highlighter-rouge">const</code>가 빠진 것에 주의!</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AutoPtr&amp;&amp; a</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">R-value reference</code>인 <code class="language-plaintext highlighter-rouge">a</code>가 참조하는 인스턴스는 메모리에 자리 잡지 않고 잠깐 있다가 사라질 R-Value.</li>
    </ul>
  </li>
  <li><strong>소유권 이동</strong>시 내용물들을 깊은 복사로 이전시킬 필요 없이 <u>✨얕은 복사✨로 집 열쇠만 넘겨주면 된다.</u>
    <ul>
      <li>따라서 복사 생성자, 일반 대입 연산자 오버로딩에 비해 훨씬 빠르다.
        <ul>
          <li>for문으로 데이터를 전부 복사시키는 깊은 복사를 하지 않기 때문에</li>
        </ul>
      </li>
      <li>얕은 복사 👉 <strong><em>m_ptr = a.m_ptr;</em></strong>
        <ul>
          <li>📢 <strong>Resource의 대입 연산자 오버로딩은 호출 되지 않는다.</strong>
            <ul>
              <li><u>Resource의 대입 연산자의 매개변수는 const가 안붙은 &amp; 레퍼런스이므로 다른 함수라고 인식되어 오버로딩 되지 않음.</u>
                <ul>
                  <li>Resource의 대입 연산자는 깊은 복사를 수행하기 때문에 깊은 복사가 되지 않도록 Resource의 대입 연산자 매개변수는 그냥 L-value Reference로 설정</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>소유권을 박탈</strong>을 반드시 해주어야 한다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">a.m_ptr = nullptr;</code></li>
      <li>별개의 새로운 공간을 만들어 내용물 데이터들을 복사한게 아니라 두 포인터가 같은 인스턴스를 가리키게 된 것이므로(✨얕은 복사✨) 복사 대상이 된 포인터의 소유권은 박탈 시켜 주어야 한다.</li>
      <li>박탈 시키지 않으면 대입 연산자 인수로 이 인스턴스를 참조 하게 된 매개 변수 <code class="language-plaintext highlighter-rouge">AutoPtr &amp;&amp; a</code>가 대입 연산자 호출이 종료됨에 따라 소멸자가 호출되어 delete될 수 있기 때문이다.</li>
    </ul>
  </li>
</ul>

<h3 id="autoptrh-1">📜AutoPtr.h</h3>

<blockquote>
  <p>이동 생성자, 이동 대입 연산자 오버로딩를 사용.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">AutoPtr</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">T</span><span class="o">*</span> <span class="n">m_ptr</span><span class="p">;</span>

<span class="nl">public:</span>
	<span class="n">AutoPtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span>
		<span class="o">:</span><span class="n">m_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AutoPtr default constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">AutoPtr</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AutoPtr destructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m_ptr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">delete</span> <span class="n">m_ptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">AutoPtr</span><span class="p">(</span><span class="n">AutoPtr</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span>  <span class="c1">// ⭐이동생성자⭐ </span>
		<span class="o">:</span>  <span class="n">m_ptr</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">)</span> <span class="c1">// ⭐얕은 복사⭐ 그냥 대입만 하면 땡이다!</span>
	<span class="p">{</span> 
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AutoPtr move constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

		<span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// really necessary?</span>
	<span class="p">}</span>

	<span class="n">AutoPtr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="n">AutoPtr</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span>  <span class="c1">// ⭐*이동 대입 연산자 오버로딩⭐ </span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AutoPtr move assignment"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

		<span class="c1">// 공간은 비워줘야하는 것 똑같고 (delete 안하고 그냥 대입하면 메모리 누수가 발생할 수 있다)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_ptr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">delete</span> <span class="n">m_ptr</span><span class="p">;</span> 
		
		<span class="n">m_ptr</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="c1">// ⭐얕은 복사⭐ 그냥 대입만 하면 땡이다!</span>
		<span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// 소유권 박탈</span>

		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">T</span><span class="o">*</span> <span class="k">operator</span> <span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">bool</span> <span class="n">inNull</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_ptr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="maincpp-1">📜main.cpp</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include "AutoPtr.h"
#include "Resource.h"
#include "Timer.h"
</span>
<span class="n">AutoPtr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">generateResource</span><span class="p">()</span>  
<span class="p">{</span>
	<span class="n">AutoPtr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="k">new</span> <span class="n">Resource</span><span class="p">(</span><span class="mi">10000000</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
	<span class="n">streambuf</span> <span class="o">*</span> <span class="n">orig_buf</span> <span class="o">=</span> <span class="n">cout</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">();</span>
	<span class="c1">// cout.rdbuf(NULL); 화면에 출력되는 메세지들 끄기. 시간 어마어마하게 걸릴 테니까!</span>

	<span class="n">Timer</span> <span class="n">timer</span><span class="p">;</span>
	<span class="p">{</span>
		<span class="n">AutoPtr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">main_res</span><span class="p">;</span>
		<span class="n">main_res</span> <span class="o">=</span> <span class="n">generateResource</span><span class="p">();</span>  <span class="c1">//generateResource() 리턴값은 R-value </span>
	<span class="p">}</span>
		<span class="n">cout</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">(</span><span class="n">orig_buf</span><span class="p">);</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">timer</span><span class="p">.</span><span class="n">elapsed</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 실행시간 재서 출력</span>
	<span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

AutoPtr default constructor
Resource length constructor
AutoPtr default constructor
AutoPtr copy assignment
AutoPtr destructor
AutoPtr destructor
0.00590591
</code></pre></div></div>
<ul>
  <li>깊은 복사를 하지 않는 다는 것을 알 수 있다.
    <ul>
      <li>Resource의 복사 생성자를 호출하지 않는 것을 볼 수 있다.</li>
      <li>실행시간 또한 복사생성자, 대입 연산자 오버로딩에 비해서 <u>더 빠른 것을 볼 수 있다</u></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="-정리">🔔 정리</h2>

<blockquote>
  <p><strong>메모리에 잠시 동안만 존재하다가 사라지는 R-value 인스턴스를 대입, 복사 할 때 대처 방법</strong></p>
</blockquote>

<blockquote>
  <p><u>R-value의 소유권을 이전할 때 2 가지 방법</u>이 있다. <strong>1️⃣깊은 복사 2️⃣얕은 복사</strong> <u>얕은 복사가 깊은 복사보다 더 빠르다.</u></p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AutoPtr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">main_res</span><span class="p">;</span>  <span class="c1">// Resource 타입의 스마트 포인터 역할을 한다.</span>
<span class="n">main_res</span> <span class="o">=</span> <span class="n">generateResource</span><span class="p">();</span> <span class="c1">// R-value 💛</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💎깊은</span> <span class="err">복사💎</span>

<span class="err">📜</span><span class="n">AutoPtr</span><span class="err">의</span> <span class="err">대입</span> <span class="err">연산자</span> 

<span class="n">m_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">;</span>    <span class="c1">// 새로운 공간 할당</span>
<span class="o">*</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="c1">// ⭐깊은 복사⭐ 를 실행하는 📜Resource의 대입 연산자 호출</span>


<span class="err">📜</span><span class="n">Resource</span><span class="err">의</span> <span class="err">대입</span> <span class="err">연산자</span> <span class="err">호출</span>

<span class="n">m_data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m_length</span><span class="p">];</span> <span class="c1">// 새로운 빈 공간 할당</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
	<span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">m_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 새로운 빈 공간에 내용물 옮기기. ⭐깊은 복사⭐</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💎얕은</span> <span class="err">복사💎</span>
<span class="err">📜</span><span class="n">AutoPtr</span><span class="err">의</span> <span class="err">대입</span> <span class="err">연산자</span> 

<span class="n">m_ptr</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="c1">// 소유권 이전 ⭐얕은 복사⭐  📜Resource의 대입 연산자 호출하지 않는다.</span>
<span class="n">a</span><span class="p">.</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// 소유권 박탈</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/42318591/89727411-88cb6200-da5f-11ea-9c5c-05d7d331790f.png" alt="image" width="90%" height="90%" class="align-center" /></p>

<h3 id="r-value를-무사히-받기-위한-첫-번째-방법--const-l-value-reference">R-value를 무사히 받기 위한 첫 번째 방법 👉 const L-value reference</h3>

<blockquote>
  <p>L-value, R-value 모두 다 참조할 수 있다.</p>
</blockquote>

<ul>
  <li>Resource타입 임시 객체를 리턴하는 함수 리턴 값 generateResource() 같은 R-value도 참조 가능!</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">const</code>라 참조 하는 대상의 값을 수정할 수 없다. 👉 소유권 박탈 불가능</p>
</blockquote>

<ul>
  <li><strong><em>소유권 이동</em></strong>시 <u>새로운, 별개의 인스턴스를 만들어서</u> 그 곳에 내용물들을 싹 다 복사해서 옮긴다(<u>깊은 복사</u>)
    <ul>
      <li>✨<u>얕은 복사는 할 수 없고 깊은 복사만 가능한 이유</u>
        <ul>
          <li>깊은 복사는 느리다. 그러나 <code class="language-plaintext highlighter-rouge">const L-value reference</code>를 사용하면 빈 인스턴스를 새로 만들어서 그 곳으로 내용물들을 전부 복사하는, 깊은 복사 방식을 사용할 수 밖에 없다.
            <ul>
              <li>단순히 <code class="language-plaintext highlighter-rouge">m_ptr = a.m_ptr</code> 이렇게 포인터만 복사하여 집 열쇠만 넘겨주는 식의 얕은 복사를 하려면 반드시 복사 대상이 된 포인터의 해당 인스턴스에 대한 소유권을 박탈(<code class="language-plaintext highlighter-rouge">a.m_ptr = nullptr</code>)시켜 주어야 하는데
                <ul>
                  <li>소유권을 박탈시켜 주지 않으면 동시에 두 포인터가 동일한 객체를 소유하게 되므로 나중에 한 포인터를 통해 메모리를 해제 시키면 문제 발생</li>
                </ul>
              </li>
              <li><code class="language-plaintext highlighter-rouge">a</code>는 <code class="language-plaintext highlighter-rouge">const L-value reference</code>, 즉 <code class="language-plaintext highlighter-rouge">const</code> 하기 때문에 값을 <code class="language-plaintext highlighter-rouge">nullptr</code>로 값을 바꿔줄 수가 없기 때문이다. 즉, <u>소유권 박탈이 불가능하기 때문에 얕은 복사를 할 수 없음.</u></li>
              <li>따라서 R-value를 복사 혹은 대입하려고 할 때 <code class="language-plaintext highlighter-rouge">const L-value reference</code>인수를 가진 복사 생성자, 대입 연산자를 사용한다면 아예 별개의 새로운 인스턴스를 만들 수 밖에 없다. 그리고 그 곳에 내용물들을 전부 복사하는 깊은 복사 방식을 할 수 밖에 없다.
                <ul>
                  <li>복사 대상이 된 기존의 인스턴스는 복사 생성자, 대입 연산자의 호출이 끝남과 동시에 지역 변수로서 delete 되어 사라져도 영향 받는게 없다. 애초에 소유권이 다른 별개의 새로운 인스턴스를 만들어 내용만 복사한 것이니까 기존의 인스턴스의 <strong><em>소유권을 박탈 시킬 필요는 없다.</em></strong>
                    <ul>
                      <li><u>자동으로 사라지니까</u></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>사실 엄밀히 말하면 아예 별개의 인스턴스이므로 동일한 인스턴스의 소유권 이전이 일어난 것은 아닌 셈이다. 전혀 다른 인스턴스에 내용만 복사 받았을 뿐임!</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">m_ptr = new T;</code>
        <ul>
          <li>Resource 타입의 별개의 새로운 인스턴스를 만들고 이를 가리키게 함</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">*m_ptr = *a.m_ptr;</code>
        <ul>
          <li>Resource의 대입 연산자를 호출한다.
            <ul>
              <li>여기서 내용물 전부를 복사하는 깊은 복사를 수행한다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>장점 👉 L-value 참조도 가능하므로 유연하다.</li>
  <li>단점 👉 깊은 복사를 사용하므로 느리다.</li>
</ul>

<h3 id="r-value를-무사히-받기-위한-두-번째-방법--r-value-reference">R-value를 무사히 받기 위한 두 번째 방법 👉 R-value reference</h3>

<blockquote>
  <p>R-value만 참조 가능하다.</p>
</blockquote>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">const</code>가 아니기 때문에 참조 하는 대상의 값을 수정할 수 있다. 👉 소유권 박탈 가능</p>
</blockquote>

<ul>
  <li><strong><em>소유권 이동</em></strong>시 <u>그냥 포인터만 복사하여 집 열쇠만 바꿔 준다.</u> 동일한 인스턴스에 대한 소유권이 두 포인터에게 있게 됨!(<u>얕은 복사</u>)</li>
  <li>반드시 기존 포인터의 <strong><em>소유권을 박탈</em></strong>시켜 주어야 한다. R-value를 담고 있는  기존 참조 변수는 이동 생성자, 이동 대입 연산자 오버로딩의 지역변수이므로 끝나고 <code class="language-plaintext highlighter-rouge">delete</code>되기 때문에 현재 인스턴스의 소유권을 두 포인터가 가지고 있으므로 반드시 소유권 박탈을 시켜주어야 한다!
    <ul>
      <li><code class="language-plaintext highlighter-rouge">a.m_ptr = nullptr</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">nullptr</code>이 되었기 때문에 소멸자에서 <code class="language-plaintext highlighter-rouge">delete</code>되지 않음!</li>
        </ul>
      </li>
      <li>안해주면 a.m_ptr이 참조하는 임시생성객체의 Resource 객체도 소멸 되므로 m_ptr = a.m_ptr 이렇게 주소 바꿔준게 헛수고가 된다.</li>
    </ul>
  </li>
  <li>장점 👉 얕은 복사를 사용하므로 빠르다.</li>
  <li>단점 👉 오직 R-value만 참조 가능하다.</li>
</ul>

<p><br /></p>

<h2 id="-번외-복사-생략">🔔 번외) 복사 생략</h2>

<blockquote>
  <p>컴파일러는 불필요한 복사 생략자 호출을 막기 위하여 일부 경우에 대해서는 복사를 생략한다.</p>
</blockquote>

<p><a href="https://modoocode.com/227#page-heading-1">모두의 코드</a>를 참고하였다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data_</span><span class="p">;</span>

 <span class="nl">public:</span>
  <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="o">:</span> <span class="n">data_</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"일반 생성자 호출!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">data_</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"복사 생성자 호출!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 일반 생성자 호출</span>
  <span class="n">A</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 복사 생성자 호출</span>

  <span class="n">A</span> <span class="n">c</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// 일반 생성자만 호출한다.</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">A c(A(2));</code>
    <ul>
      <li>R-value인 익명 객체 <code class="language-plaintext highlighter-rouge">A(2)</code>가 생성되면서 일반 생성자가 호출된다.</li>
      <li>뒤 이어 <code class="language-plaintext highlighter-rouge">A(2)</code>를 복사하여 <code class="language-plaintext highlighter-rouge">c</code>를 생성하며 복사 생성자가 호출될 것 같지만 실제론 복사 생성자가 호출되지 않는다! <code class="language-plaintext highlighter-rouge">const L-value Reference</code>는 R-value를 받을 수 있는데도 불구하고!
        <ul>
          <li>굳이 ‘복사’를 하지 않고 그냥 <code class="language-plaintext highlighter-rouge">c</code> 자체를 <code class="language-plaintext highlighter-rouge">A(2)</code>로 만들어진 객체로 해버리는 것이 성능적으로 더 낫기 때문이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이처럼 컴파일러 판단하에 복사를 생략해 버리는 작업을 <strong>복사 생략</strong>이라고 한다.</li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a>
<br /></p>
:ET