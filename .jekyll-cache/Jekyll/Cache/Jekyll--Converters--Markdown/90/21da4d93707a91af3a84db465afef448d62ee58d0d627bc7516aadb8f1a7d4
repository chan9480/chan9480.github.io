I"/<h1 id="스택--큐--우선순위-큐">스택 &amp; 큐 &amp; 우선순위 큐</h1>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Container Adaptor</code> 👉 <u>다른 컨테이너 클래스</u>들을 상속 받아서 다른 컨테이터 클래스의 객체에 <u>특정한 인터페이스</u>를 제공해준다.</p>
</blockquote>

<ul>
  <li>순서 인덱스로 접근하는 <code class="language-plaintext highlighter-rouge">Sequence Container</code>, Key로 접근하는 <code class="language-plaintext highlighter-rouge">Associative Container</code>과는 다르게 <code class="language-plaintext highlighter-rouge">pop()</code> 연산을 통해 삭제시킬 때만 접근할 수 있다.</li>
</ul>

<h2 id="-스택">🔔 스택</h2>

<blockquote>
  <p>#include &lt;stack&gt;</p>
</blockquote>

<ul>
  <li>삽입되고 삭제되는 쪽이 한쪽 밖에 없다.
    <ul>
      <li>삽입, 삭제가 모두 <code class="language-plaintext highlighter-rouge">top</code>에서 이루어짐.</li>
    </ul>
  </li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">LIFO</code> 방식으로 구현할 때 사용된다.
    <ul>
      <li>가장 먼저 삽입된 것이 가장 나중에 삭제되고</li>
      <li>가장 나중에 삽입된 것이 가장 먼저 삭제된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DFS</code> 깊이 우선 탐색에 사용 된다.</li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vector</code>, <code class="language-plaintext highlighter-rouge">deque</code>, <code class="language-plaintext highlighter-rouge">list</code> 를 기반으로 사용 가능하다.
    <ul>
      <li>내부적으로는 <code class="language-plaintext highlighter-rouge">vecotr</code>, <code class="language-plaintext highlighter-rouge">deque</code>, <code class="language-plaintext highlighter-rouge">list</code> 구조로 구현이 되어 있되 <code class="language-plaintext highlighter-rouge">statck</code>과 같이 작동하도록 멤버 함수를 지원한다.</li>
      <li>디폴트로 <code class="language-plaintext highlighter-rouge">deque</code> 기반으로 작동한다.</li>
    </ul>
  </li>
</ul>

<h3 id="함수">함수</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">size()</code> : 스택의 size. 원소 개수 리턴</li>
  <li><code class="language-plaintext highlighter-rouge">empty()</code> : 스택이 빈 스택인지, 즉 원소 개수가 0 인지에 대한 true or false 리턴</li>
  <li><code class="language-plaintext highlighter-rouge">top()</code> : <u>스택에서 가장 나중에 들어간 원소 리턴</u> 삽입 삭제시 무조건 여기서 이루어진다.</li>
  <li><code class="language-plaintext highlighter-rouge">push(n)</code> : 스택에 원소를 삽입</li>
  <li><code class="language-plaintext highlighter-rouge">pop()</code> : <code class="language-plaintext highlighter-rouge">top()</code>을 삭제한다. 가장 나중에 들어간 원소 삭제</li>
</ul>

<blockquote>
  <p>다른 컨테이너들과 다르게 <code class="language-plaintext highlighter-rouge">clear()</code>같은 함수가 없기 때문에 일일이 <code class="language-plaintext highlighter-rouge">pop()</code> 해주어야 한다.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="-큐">🔔 큐</h2>

<blockquote>
  <p>#include &lt;queue&gt;</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">back</code>에서 삽입이 이루어지고 <code class="language-plaintext highlighter-rouge">front</code>에서 삭제가 이루어진다.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">FIFO</code> 방식으로 구현할 때 사용된다.
    <ul>
      <li>가장 먼저 삽입된 것이 가장 먼저 삭제되고</li>
      <li>가장 나중에 삽입된 것이 가장 나중에 삭제된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">BFS</code> 너비 우선 탐색에 사용 된다.</li>
</ol>

<h3 id="함수-1">함수</h3>

<ul>
  <li>스택의 <code class="language-plaintext highlighter-rouge">top</code>과 다르게
    <ul>
      <li><code class="language-plaintext highlighter-rouge">front()</code> : <u>스택에서 가장 먼저 들어간 원소 리턴</u></li>
      <li><code class="language-plaintext highlighter-rouge">back()</code> : <u>스택에서 가장 나중에 들어간 원소 리턴</u></li>
    </ul>
  </li>
  <li>
    <p><strong>다른건 다 스택과 동일하다!</strong></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">deque</code>, <code class="language-plaintext highlighter-rouge">list</code> 를 기반으로 사용 가능하다.
    <ul>
      <li>내부적으로는 <code class="language-plaintext highlighter-rouge">deque</code>, <code class="language-plaintext highlighter-rouge">list</code> 구조로 구현이 되어 있되 <code class="language-plaintext highlighter-rouge">queue</code>과 같이 작동하도록 멤버 함수를 지원한다.</li>
      <li>디폴트로 <code class="language-plaintext highlighter-rouge">deque</code> 기반으로 작동한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">vector</code>는 불가능하다.
    <ul>
      <li>큐 특성상 뒤에서 삽입하고 앞에서 빠져야 하는데 <code class="language-plaintext highlighter-rouge">vector</code>는 앞에서 삭제되는 동작은 지원하지 않기 때문.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="-우선순위-큐">🔔 우선순위 큐</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">pop</code> 연산시 시간 복잡도가 \(logN\) 밖에 걸리지 않는다.
    <ul>
      <li>Heap 이라서</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;queue&gt;
</span>
<span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>#include &lt;queue&gt;</p>
</blockquote>

<ul>
  <li>✨우선순위 큐 또한 <code class="language-plaintext highlighter-rouge">queue</code> 헤더에서 지원한다.</li>
  <li>내림차순 정렬, 즉 <code class="language-plaintext highlighter-rouge">Max Heap</code>이 디폴트다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>
<span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>위의 두 선언은 동일한 선언이다.
    <ul>
      <li>디폴트로 <code class="language-plaintext highlighter-rouge">vector</code> 위에서 돌아가게 된다. 힙을 구현할 수 있는 컨테이너면 다 괜찮다.</li>
      <li>디폴트로 <code class="language-plaintext highlighter-rouge">Max Heap</code> 즉 내림 차순인 <code class="language-plaintext highlighter-rouge">less&lt;int&gt;</code> 최대값부터 <em>pop</em>이 된다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>오름차순인 <code class="language-plaintext highlighter-rouge">greater&lt;int&gt;</code> 즉, <code class="language-plaintext highlighter-rouge">Min Heap</code>으로 가장 최소값이 먼저 나오도록 한다.</li>
  <li>비교 연산자 <code class="language-plaintext highlighter-rouge">&lt;</code>을 오름차순(<code class="language-plaintext highlighter-rouge">Min Heap</code>)으로 오버로딩 해도 된다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">cmp</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// 오름 차순</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cmp</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>

</code></pre></div></div>

<ul>
  <li>위와 같이 정렬 기준을 직접 구현할 수도 있다!
    <ul>
      <li>구조체 안에 <code class="language-plaintext highlighter-rouge">()</code>연산자를 오버로딩하여 이 안에 비교 방식을 직접 사용자 정의 할 수 있다.</li>
      <li>인수로 넘길땐 <code class="language-plaintext highlighter-rouge">cmp()</code> 연산자는 생략하고 구조체 이름 <code class="language-plaintext highlighter-rouge">cmp</code>만 넘겨주면 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="함수-2">함수</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">queue</code>와 다르게 <u>front, back을 사용하지 않고</u> <code class="language-plaintext highlighter-rouge">stack</code>처럼 <u>top</u>을 사용한다.</p>
</blockquote>

<ul>
  <li>어차피 큐에 넣더라도 일반 큐처럼 들어간 순서대로 나오는 것이 아닌 우선순위(ex. 값의 크기)에 따라 나오기 때문에 그런 것 같다.</li>
  <li><code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">top</code>, <code class="language-plaintext highlighter-rouge">size</code>, <code class="language-plaintext highlighter-rouge">empty</code> <code class="language-plaintext highlighter-rouge">pop</code> 스택 함수들과 동일</li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET