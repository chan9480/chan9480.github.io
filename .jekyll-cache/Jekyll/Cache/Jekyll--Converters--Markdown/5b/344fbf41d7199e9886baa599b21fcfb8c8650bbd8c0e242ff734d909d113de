I"5r<h2 id="-map-set-unordered_map-unordered_set-자세한-설명">🚀 map, set, unordered_map, unordered_set 자세한 설명</h2>

<ul>
  <li><a href="https://ansohxxn.github.io/stl/map/">[STL 컨테이너] map &amp; unordered_map &amp; multimap</a></li>
  <li><a href="https://ansohxxn.github.io/stl/set/">[STL 컨테이너] set &amp; unordered_set &amp; multiset</a></li>
  <li><a href="https://ansohxxn.github.io/stl/sortmapset/">[STL 컨테이너] map 과 set의 정렬</a></li>
</ul>

<p><br /></p>

<h2 id="-map-set-에서-커스텀-구조체-or-객체-저장하기--정렬된-순서를-유지">🚀 <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">set</code> 에서 커스텀 구조체 or 객체 저장하기 (👉 정렬된 순서를 유지)</h2>

<p><code class="language-plaintext highlighter-rouge">map</code>과 <code class="language-plaintext highlighter-rouge">set</code>은 정렬된 상태를 유지하기 때문에 <code class="language-plaintext highlighter-rouge">int</code> 같은 기본 자료형이 아닌, 우리가 직접 만든 구조체나 클래스와 같은 <strong>‘사용자 지정 자료형’을 저장하려할 때는 <u>operator &lt; 연산자를 const 함수로 오버로딩 해주어야 한다.</u></strong>(뒤에 <code class="language-plaintext highlighter-rouge">const</code> 붙여주어야 한다.) 즉, 같은 타입의 인스턴스끼리 크기를 비교할 수 있는 어떤 비교 기준을 마련해주어야 하는 것이다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">set</code> 👉 원소의 타입에 대한 비교기준</li>
  <li><code class="language-plaintext highlighter-rouge">map</code> 👉 Key 의 타입에 대한 비교 기준 (map은 Key 를 기준으로 정렬한다. 즉, Key 가 사용자 지정 자료형일 때)</li>
</ul>

<p><br /></p>

<h3 id="-첫-번째-방법--멤버-함수로서--연산자-오버로딩-정의">🔥 첫 번째 방법 : 멤버 함수로서 &lt; 연산자 오버로딩 정의</h3>

<p>구조체 혹은 클래스 내부에서 멤버 함수로서 <code class="language-plaintext highlighter-rouge">&lt;</code> 연산자를 오버로딩하여 구조체 혹은 클래스 자체에 비교 기준을 부여한다.</p>

<h4 id="-set">✈ <code class="language-plaintext highlighter-rouge">set</code></h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Student</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">grade</span><span class="p">;</span>

    <span class="c1">// Student 구조체들은 name을 비교 기준으로 정렬하고자 한다. name 이 같다면 grade 로 비교하기로 약속함!</span>
    <span class="c1">// 여기서 name 은 Student 구조체 인스턴스 입장에서 나의 name</span>
    <span class="c1">// 여기서 other.name 은 비교 대상이 되는 다른 Student 구조체 인스턴스의 name (other은 비교 대상이 되는 다른 Student 구조체)</span>
    <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grade</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">grade</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">students</span><span class="p">;</span>
    
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"ryan"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">});</span>
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"muzi"</span><span class="p">,</span> <span class="mi">3</span> <span class="p">});</span>
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"muzi"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">});</span>
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"apeach"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">});</span>
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"apeach"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">});</span> <span class="c1">// set은 중복을 허용하지 않으므로 이건 삽입되지 않는다.</span>

    <span class="c1">// 출력을 통해 name 을 기준으로(name이 같다면 grade로) 정렬된 모습 확인 가능!</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">stu</span> <span class="o">:</span> <span class="n">students</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stu</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">stu</span><span class="p">.</span><span class="n">grade</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

apeach : 1
muzi : 1
muzi : 3
ryan : 5
</code></pre></div></div>

<p><br /></p>

<h4 id="-map">✈ <code class="language-plaintext highlighter-rouge">map</code></h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Student</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">grade</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grade</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">grade</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">Student</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">students2</span><span class="p">;</span>
    <span class="n">students2</span><span class="p">[{</span><span class="s">"prodo"</span><span class="p">,</span> <span class="mi">2</span><span class="p">}]</span> <span class="o">=</span> <span class="s">"착함"</span><span class="p">;</span>
    <span class="n">students2</span><span class="p">[{</span><span class="s">"con"</span><span class="p">,</span> <span class="mi">4</span><span class="p">}]</span> <span class="o">=</span> <span class="s">"노래를 잘함"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">stu</span> <span class="o">:</span> <span class="n">students2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stu</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

노래를 잘함
착함
</code></pre></div></div>

<p><br /></p>

<h3 id="-두-번째-방법--비교-함수-만들기--연산자">🔥 두 번째 방법 : 비교 함수 만들기 () 연산자</h3>

<p>따로 비교 전용 구조체를 만들어 <code class="language-plaintext highlighter-rouge">()</code> 연산자를 오버로딩한 후 그 안에 <u>"두 인스턴스"의 비교 기준</u> 을 정의해준다. 그리고 <code class="language-plaintext highlighter-rouge">set</code>은 구체화시 두 번째 파라미터로, <code class="language-plaintext highlighter-rouge">map</code>은 세 번째 파라미터로 해당 비교 전용 구조체를 넘겨주면 된다. <strong>이렇게 비교 함수를 두 파라미터를 받는 전역 함수 느낌으로 만들 경우, 구조체를 따로 만들어 이 안에다가 비교함수를 정의해준 후 STL 함수들에 이 구조체를 넘기는 식인듯 하다!</strong> <em>sort</em> 함수도 그랬고..!</p>

<h4 id="-set-1">✈ set</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Student</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">grade</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 구조체를 따로 만들어서 () 연산자를 오버로딩한 후 그 안에 비교 기준을 정의한다.</span>
<span class="c1">// 멤버 함수로서 내부에 저장한 것이 아니기 때문에 파라미터가 2 개가 필요하다. 같은 타입의 두 인스턴스 비교!</span>
<span class="c1">// stu1 가 참조하는 인스턴스와 stu2 가 참조하는 인스턴스의 비교</span>
<span class="k">struct</span> <span class="nc">cmp</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">stu1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">stu2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stu1</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">stu2</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">stu1</span><span class="p">.</span><span class="n">grade</span> <span class="o">&lt;</span> <span class="n">stu2</span><span class="p">.</span><span class="n">grade</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">stu1</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">stu2</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">Student</span><span class="p">,</span> <span class="n">cmp</span><span class="o">&gt;</span> <span class="n">students</span><span class="p">;</span> <span class="c1">// 비교함수를 안에 정의해준 cmp 구조체를 함께 넘긴다.</span>

    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"ryan"</span><span class="p">,</span> <span class="mi">5</span> <span class="p">});</span>
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"muzi"</span><span class="p">,</span> <span class="mi">3</span> <span class="p">});</span>
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"muzi"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">});</span>
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"apeach"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">});</span>
    <span class="n">students</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span> <span class="s">"apeach"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">stu</span> <span class="o">:</span> <span class="n">students</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stu</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">stu</span><span class="p">.</span><span class="n">grade</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

apeach : 1
muzi : 1
muzi : 3
ryan : 5
</code></pre></div></div>

<p><br /></p>

<h4 id="-map-1">✈ map</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Student</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">grade</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">cmp</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">stu1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">stu2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stu1</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">stu2</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">stu1</span><span class="p">.</span><span class="n">grade</span> <span class="o">&lt;</span> <span class="n">stu2</span><span class="p">.</span><span class="n">grade</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">stu1</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">stu2</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">Student</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">cmp</span><span class="o">&gt;</span> <span class="n">students2</span><span class="p">;</span> <span class="c1">// 비교함수를 안에 정의해준 cmp 구조체를 함께 넘긴다.</span>
    <span class="n">students2</span><span class="p">[{</span><span class="s">"prodo"</span><span class="p">,</span> <span class="mi">2</span><span class="p">}]</span> <span class="o">=</span> <span class="s">"착함"</span><span class="p">;</span>
    <span class="n">students2</span><span class="p">[{</span><span class="s">"con"</span><span class="p">,</span> <span class="mi">4</span><span class="p">}]</span> <span class="o">=</span> <span class="s">"노래를 잘함"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">stu</span> <span class="o">:</span> <span class="n">students2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stu</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

노래를 잘함
착함
</code></pre></div></div>

<h2 id="-unordered_map-unordered_set-에서-커스텀-구조체-or-객체-저장하기--정렬-안됨-해시-함수-사용">🚀 <code class="language-plaintext highlighter-rouge">unordered_map</code>, <code class="language-plaintext highlighter-rouge">unordered_set</code> 에서 커스텀 구조체 or 객체 저장하기 (👉 정렬 안됨, 해시 함수 사용)</h2>

<ul>
  <li>1️⃣ 해시 함수 만들기
    <ul>
      <li>해당 구조체 혹은 클래스 타입의 전용 해시 함수를 직접 만들어주어야 하는데
        <ul>
          <li><em>C++ 에서 제공하는 기본 자료형에 대한 해시 함수</em>를 사용하여 해시값을 만들어내도 되고</li>
          <li><em>XOR 연산자</em> 를 사용하여 만드는 방법도 있다.</li>
          <li>무슨 방법을 쓰던, <u>최대한!! 같은 해시값이 리턴되지 않도록, 즉 해시 충돌이 발생하지 않도록 해시 함수를 짜는게 좋다.</u> ✨✨ 최대한 파라미터에 따라 고유한 해시값이 나오도록 해야 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>2️⃣ <code class="language-plaintext highlighter-rouge">==</code> 연산자 오버로딩이 필요하다.
    <ul>
      <li>해시 충돌(해시값 동일) 발생시 원소 비교가 가능해야하기 때문이다.
        <ul>
          <li>두 인스턴스가 같다고 판단할 수 있는 그 기준이 필요하다.</li>
        </ul>
      </li>
      <li>해시 함수 값으로 저장된 데이터를 찾는 <code class="language-plaintext highlighter-rouge">unordered_map</code>, <code class="language-plaintext highlighter-rouge">unordered_set</code>는 정렬이 필요 없으므로 <code class="language-plaintext highlighter-rouge">&lt;</code> 연산자는 필요 없다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="1️⃣-해시함수">1️⃣ 해시함수</h3>

<h4 id="첫-번째-방법">첫 번째 방법</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">hash</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">stu</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">hash_func</span><span class="p">;</span> <span class="c1">// string 을 파라미터로 받아 해시 함수값을 리턴해주는 C++ 제공 해시 객체</span>

            <span class="k">return</span> <span class="n">hash_func</span><span class="p">(</span><span class="n">stu</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">^</span> <span class="n">stu</span><span class="p">.</span><span class="n">grade</span><span class="p">;</span> <span class="c1">// 임의로 string 인 name 의 해시함수값과 int인 grade 값을 XOR 연산한 것을 해시 함수 값으로 하기로 정의!</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">namespace std</code> 안에 정의해야 한다.</li>
  <li>구조체의 이름은 <code class="language-plaintext highlighter-rouge">hash&lt;사용자정의타입이름&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">()</code> 연산자를 오버로딩한다.
    <ul>
      <li>이 안에 해시 함수를 정의한다.</li>
      <li>해시 함수 값을 리턴하기에 리턴 타입은 <code class="language-plaintext highlighter-rouge">size_t</code> (unsigend_int)</li>
    </ul>
  </li>
  <li>C++은 <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">string</code> 등등 기본 타입의 인스턴스를 파라미터로 받아 어떤 해시 함수 값을 생성해주는 그런 객체를 제공하고 있다. <em>ex) hash&lt;string&gt; hash_func 👉 string 을 파라미터로 받아 해시 함수값을 리턴해주는 C++ 제공 해시 객체</em>
    <ul>
      <li>이 해시 객체를 이용하여 구조체 혹은 클래스의 멤버들과 <em>XOR</em> 연산도 좀 섞어보고.. 잘 짬뽕하여.. 해시 함수를 만들어주면 된다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">map1</span><span class="p">;</span> <span class="c1">// ⭕</span>
<span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Student</span><span class="p">,</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;&gt;</span> <span class="n">map1</span><span class="p">;</span> <span class="c1">// ⭕</span>
</code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">std</code> 네임스페이스 안에서 <code class="language-plaintext highlighter-rouge">hash&lt;구조체이름&gt;</code> 사용하여 그 안에 정의하면 위와 같이 해시맵 자료구조를 선언할 때 파라미터로 <code class="language-plaintext highlighter-rouge">hash&lt;구조체이름&gt;</code>를 안넣어주어도 된다.</p>

<p><br /></p>

<h4 id="두-번째-방법">두 번째 방법</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="nc">MyHash</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">stu</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">hash_func</span><span class="p">;</span> <span class="c1">// string 을 파라미터로 받아 해시 함수값을 리턴해주는 C++ 제공 해시 객체</span>

            <span class="k">return</span> <span class="n">hash_func</span><span class="p">(</span><span class="n">stu</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">^</span> <span class="n">stu</span><span class="p">.</span><span class="n">grade</span><span class="p">;</span> <span class="c1">// 임의로 string 인 name 의 해시함수값과 int인 grade 값을 XOR 연산한 것을 해시 함수 값으로 하기로 정의!</span>
        <span class="p">}</span>
    <span class="p">};</span>
</code></pre></div></div>

<p>이렇게 그냥 사용자 정의 구조체 안에서 <code class="language-plaintext highlighter-rouge">()</code> 연산자를 오버로딩하여 해시함수를 구현해주면</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">map1</span><span class="p">;</span> <span class="c1">// ❌</span>
<span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Student</span><span class="p">,</span> <span class="n">MyHash</span><span class="o">&gt;</span> <span class="n">map1</span><span class="p">;</span> <span class="c1">// ⭕</span>
</code></pre></div></div>

<p>이땐 꼭 파라미터로 해당 구조체 이름을 함께 넘겨주어야 한다.</p>

<p><br /></p>

<h3 id="2️⃣--연산자-오버로딩">2️⃣ == 연산자 오버로딩</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Student</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">grade</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">grade</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">grade</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>해시 충돌이 일어났을 때, 즉 이미 해시테이블 안에 있는 어떤 요소와 해시값이 동일하게 나왔을 때 버킷 안에 있는 원소들과 비교해야하기 때문에 <code class="language-plaintext highlighter-rouge">==</code> 연산자 오버로딩이 필요하다.</p>

<p><br /></p>

<h2 id="-출처-및-참고">🚀 출처 및 참고</h2>

<ul>
  <li>커스텀 해시 함수를 사용했던 코테 문제 <a href="https://ansohxxn.github.io/programmers/128/">[C++로 풀이] 블록 이동하기 (BFS)⭐⭐⭐</a></li>
  <li>윗 내용 모두 <a href="https://modoocode.com/224">모두의 코드</a> 를 참고했습니다. :)</li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET