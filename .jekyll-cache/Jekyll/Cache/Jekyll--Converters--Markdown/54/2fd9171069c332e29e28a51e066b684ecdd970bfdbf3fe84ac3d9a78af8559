I"=<p class="notice--warning">인프런에 있는 홍정모 교수님의 <strong>홍정모의 따라 하며 배우는 C++</strong> 강의를 듣고 정리한 필기입니다. 😀  <br />
<a href="https://www.inflearn.com/course/following-c-plus">🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!</a></p>

<p><br /></p>

<h1 id="chapter-8-객체-지향의-기초--this포인터와-연쇄-호출">chapter 8. 객체 지향의 기초 : this포인터와 연쇄 호출</h1>

<h2 id="-this-포인터">🔔 this 포인터</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">this</code> : 자기 자신(<strong>객체</strong>)의 주소를 담는 포인터다.</p>
</blockquote>

<ul>
  <li>포인터이므로
    <ul>
      <li><code class="language-plaintext highlighter-rouge">this -&gt; 멤버</code> 로 접근한다.</li>
      <li><code class="language-plaintext highlighter-rouge">(*this).멤버</code> 이렇게 간접참조로 접근할 수도 있다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">*this</code> : 자기 자신(객체).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>원래 클래스 내에서 멤버들을 사용할 때 앞에 다 <code class="language-plaintext highlighter-rouge">this-&gt;</code>가 붙는데 생략되는 것이다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Simple</span>
<span class="p">{</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_id</span><span class="p">;</span>

<span class="nl">public:</span> 
	<span class="n">Simple</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
	<span class="p">{</span>
        
        <span class="n">setID</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>  <span class="c1">// this-&gt;setID(id)와 같다.</span>
        
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_id</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// cout &lt;&lt; this-&gt;m_id &lt;&lt; endl 와 같다.</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">setID</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">int</span> <span class="n">getID</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_id</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Simple</span> <span class="n">s1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 1,  0x7ffccf6ae898 출력</span>
    <span class="n">Simple</span> <span class="n">s2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// 2,  0x7ffccf6ae89c 출력</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">s2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 0x7ffccf6ae898 0x7ffccf6ae89c 출력</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎
1 
0x7ffccf6ae898
2 
0x7ffccf6ae89c       
0x7ffccf6ae898 0x7ffccf6ae89c 
</code></pre></div></div>

<p>출력 결과를 보면 <code class="language-plaintext highlighter-rouge">this</code> 값이 객체 주소값과 일치하는 것을 알 수 있다. 객체 <em>s1</em>가 생성될 때 실행했을 생성자가 <code class="language-plaintext highlighter-rouge">this</code> 값을 출력하는데 이는 <u>&amp;s1과 일치한다.</u></p>

<blockquote>
  <p><em>여담으로 위 코드에서 생성자 내부에 있는 setID 멤버 함수의 실행을 보고 객체를 생성하기도 전인데 어떻게 멤버함수를 벌써 생성자에서 실행할 수 있는지 헷갈렸다. 그러나 문제 없다! 객체가 생성되는 순간 생성자가 실행되는건 맞지만 생성자의 대괄호 범위는 이미 객체가 생성된 뒤에 실행되기 때문에 생성자 내에서 멤버 함수를 사용하는 것은 문제 없다.</em></p>
</blockquote>

<p><br /></p>

<h2 id="-연쇄-호출">🔔 연쇄 호출</h2>

<h3 id="연쇄-호출을-사용하지-않은-경우">연쇄 호출을 사용하지 않은 경우</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Calc</span>
<span class="p">{</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_value</span><span class="p">;</span>

<span class="nl">public:</span> 
	<span class="n">Calc</span><span class="p">(</span><span class="kt">int</span> <span class="n">init_value</span><span class="p">)</span>     <span class="c1">//생성자</span>
		<span class="o">:</span> <span class="n">m_value</span><span class="p">(</span><span class="n">init_value</span><span class="p">)</span>
	<span class="p">{}</span>
	<span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;}</span>
	<span class="kt">void</span> <span class="n">sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">-=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">void</span> <span class="n">mult</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">*=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>  <span class="cm">/* 매우 번거롭다 ! */</span>
	<span class="n">Calc</span> <span class="n">cal</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">cal</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">cal</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">cal</span><span class="p">.</span><span class="n">mult</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">cal</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>멤버함수들을 연이어 호출할 때 계속 <em>cal.</em> 을 반복하여 쓰는게 번거롭다. 이때 <u>this포인터를 이용한 연쇄호출</u>을 사용하면 한 줄로 깔끔하게 요약할 수 있다.</p>

<p><br /></p>

<h3 id="연쇄-호출을-사용한-경우">연쇄 호출을 사용한 경우</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Calc</span>
<span class="p">{</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_value</span><span class="p">;</span>

<span class="nl">public:</span> 
	<span class="n">Calc</span><span class="p">(</span><span class="kt">int</span> <span class="n">init_value</span><span class="p">)</span>     <span class="c1">//생성자</span>
		<span class="o">:</span> <span class="n">m_value</span><span class="p">(</span><span class="n">init_value</span><span class="p">)</span>
	<span class="p">{}</span>
	<span class="n">Calc</span><span class="o">&amp;</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;}</span>
	<span class="n">Calc</span><span class="o">&amp;</span> <span class="n">sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">-=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">Calc</span><span class="o">&amp;</span> <span class="n">mult</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">*=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;}</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>  <span class="cm">/* 매우 번거롭다 ! */</span>
	<span class="n">Calc</span> <span class="n">cal</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">cal</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">mult</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">print</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>각 멤버함수의 리턴 타입을 <code class="language-plaintext highlighter-rouge">Calc&amp;</code> 객체 참조로 하고 이를 <code class="language-plaintext highlighter-rouge">*this</code>로, 즉 자기 자신(객체)를 리턴하니 <em>cal.add(10).sub(1).mult(2),print();</em> 한 줄로 깔끔하게 실행할 수 있게 되었다. 위 코드는 사실 아래 코드의 과정과 동일하다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Calc</span> <span class="nf">cal</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">Calc</span> <span class="o">&amp;</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">cal</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// temp1은 cal 메모리를 참조한다.</span>
<span class="n">Calc</span> <span class="o">&amp;</span> <span class="n">temp2</span> <span class="o">=</span> <span class="n">temp1</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// temp1, temp2은 cal 메모리를 참조한다.</span>
<span class="n">Calc</span> <span class="o">&amp;</span> <span class="n">temp3</span> <span class="o">=</span> <span class="n">temp2</span><span class="p">.</span><span class="n">mult</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// temp1, temp2, temp3은 cal 메모리를 참조한다.</span>
<span class="n">temp3</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="일반-리턴">일반 리턴</h4>
<ul>
  <li>그냥 <code class="language-plaintext highlighter-rouge">Calc</code>로 리턴 할 때. <em>Calc add(int value){ return *this; }</em>
    <ul>
      <li><u>Calc타입의 임시 변수</u>에 자기 자신(Calc 타입 객체)이 복사된 후 그 <u>임시 변수를 리턴</u>한다.</li>
      <li>즉, 진짜 자기 자신의 객체를 리턴하는 것이 아닌 주소가 다른 또 다른 Calc 타입의 객체를 리턴하는 것.
        <ul>
          <li>자기 자신이 복사 되었을 뿐.</li>
        </ul>
      </li>
      <li>임시 변수는 지역 변수로서 함수가 수명이 다하며 같이 사라진다.
        <ul>
          <li><strong><em>R-value 속성</em></strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="참조-리턴">참조 리턴</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Calc &amp;</code>참조로 리턴할 때. <em>Calc &amp; add(int value){ return *this; }</em>
    <ul>
      <li><u>진짜 자기 자신(Calc 타입 객체)의 레퍼런스를 리턴</u>하는 것이므로 실제 자기 자신 그 자체를 리턴한다.
        <ul>
          <li>임시 변수에 복사하는 것 없이</li>
        </ul>
      </li>
      <li>자기 자신 자체를 참조하는 Calc 레퍼런스를 리턴한다.
        <ul>
          <li><strong><em>L-value 속성</em></strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="https://ansohxxn.github.io/cpp/chapter7-3/">7.3 다양한 리턴 값 포스트 참고</a></li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>

<p><br /></p>
:ET