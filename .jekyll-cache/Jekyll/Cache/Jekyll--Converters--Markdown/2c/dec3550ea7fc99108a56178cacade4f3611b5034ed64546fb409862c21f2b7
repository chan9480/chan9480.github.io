I"lH<p class="notice--warning">인프런에 있는 홍정모 교수님의 <strong>홍정모의 따라 하며 배우는 C++</strong> 강의를 듣고 정리한 필기입니다. 😀  <br />
<a href="https://www.inflearn.com/course/following-c-plus">🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!</a></p>

<p><br /></p>

<h1 id="chapter-9-연산자-오버로딩--복사-생성자-복사-생략-리턴값-최적화">chapter 9. 연산자 오버로딩 : 복사 생성자, 복사 생략, 리턴값 최적화</h1>

<h2 id="-복사-생성자">🔔 복사 생성자</h2>

<p>복사 생성자는 <a href="https://ansohxxn.github.io/cpp/chapter8-9/#-%EB%B3%B5%EC%82%AC-%EC%83%9D%EC%84%B1%EC%9E%90">이 포스트</a>에서 한번 만났었다!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">복사 생성자</code> : 어떤 객체를 <strong>복사</strong>하여 똑같은 타입의 객체를 생성할 때 복사 생성자가 호출된다.</p>
</blockquote>

<p><br /></p>

<h3 id="복사-생성자-만들기">복사 생성자 만들기</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Fraction</span><span class="p">(</span><span class="k">const</span> <span class="n">Fraction</span> <span class="o">&amp;</span><span class="n">fraction</span><span class="p">)</span>  <span class="c1">// copy constructor</span>
	<span class="o">:</span><span class="n">m_numerator</span><span class="p">(</span><span class="n">fraction</span><span class="p">.</span><span class="n">m_numerator</span><span class="p">),</span> <span class="n">m_denominator</span><span class="p">(</span><span class="n">fraction</span><span class="p">.</span><span class="n">m_denominator</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>복사 생성자는 <u>복사할 대상을 인수로 받는다.</u>
    <ul>
      <li><strong>const</strong>
        <ul>
          <li>그저 복사만 할 것이라 복사할 대상으로 들어온 객체의 멤버 값을 변경 안할 것.</li>
        </ul>
      </li>
      <li>복사할 대상은 <strong>같은 타입의 Fraction 객체</strong>이다.</li>
      <li>메모리 낭비를 줄이기 위해 <strong>참조</strong>로 가져 온다.</li>
    </ul>
  </li>
  <li><u>멤버 변수 값들을 전부 복사해와 초기화 한다.</u></li>
</ul>

<p><br /></p>

<h3 id="복사-생성자가-호출될-때">복사 생성자가 호출될 때</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cassert&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Fraction</span>
<span class="p">{</span>
<span class="nl">private:</span>
	<span class="kt">int</span> <span class="n">m_numerator</span><span class="p">;</span>  <span class="c1">// 분자</span>
	<span class="kt">int</span> <span class="n">m_denominator</span><span class="p">;</span> <span class="c1">// 분모</span>

<span class="nl">public:</span>
	<span class="n">Fraction</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">m_numerator</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">m_denominator</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">den</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 분모가 0이면 안됨</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
	<span class="p">}</span>
	
	<span class="n">Fraction</span><span class="p">(</span><span class="k">const</span> <span class="n">Fraction</span> <span class="o">&amp;</span><span class="n">fraction</span><span class="p">)</span>  <span class="c1">// ✨ 복사 생성자</span>
		<span class="o">:</span><span class="n">m_numerator</span><span class="p">(</span><span class="n">fraction</span><span class="p">.</span><span class="n">m_numerator</span><span class="p">),</span> <span class="n">m_denominator</span><span class="p">(</span><span class="n">fraction</span><span class="p">.</span><span class="n">m_denominator</span><span class="p">)</span>
	<span class="p">{</span> 
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
	<span class="p">}</span>

	<span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Fraction</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">m_numerator</span> <span class="o">&lt;&lt;</span> <span class="s">"/"</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">m_denominator</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Fraction</span> <span class="n">frac</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

	<span class="n">Fraction</span> <span class="n">fr_copy</span><span class="p">(</span><span class="n">frac</span><span class="p">);</span>  <span class="c1">// 👈👈 복사생성자가 호출 된다!</span>
    <span class="n">Fraction</span> <span class="n">fr_copy2</span> <span class="o">=</span> <span class="n">frac</span><span class="p">;</span>   <span class="c1">// 👈👈 복사생성자가 호출 된다!</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">frac</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">fr_copy</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">fr_copy2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 3/5 3/5 3/5 출력</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>Fraction <code class="language-plaintext highlighter-rouge">fr_copy</code>(frac);</em></strong>
    <ul>
      <li>객체 <code class="language-plaintext highlighter-rouge">fr_copy</code>는 자기 자신과 같은 타입인 <code class="language-plaintext highlighter-rouge">frac</code>객체를 인수로 받아 생성되는 객체이다.</li>
      <li>자신을 생성하고 <code class="language-plaintext highlighter-rouge">frac</code>객체의 멤버 값들을 자신의 멤버에 복사한다.</li>
      <li><u>복사 생성자</u>가 호출된다.</li>
    </ul>
  </li>
  <li><strong><em>Fraction <code class="language-plaintext highlighter-rouge">fr_copy2</code> = frac;</em></strong>
    <ul>
      <li>이렇게 <strong><u>복사 초기화로 대입할 때도 복사 생성자가 호출</u></strong>된다.</li>
      <li>자신(<code class="language-plaintext highlighter-rouge">fr_copy2</code> 객체)을 생성하고 <code class="language-plaintext highlighter-rouge">frac</code>객체의 멤버 값들을 자신의 멤버에 복사한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="복사-과정이-생략될-때">복사 과정이 생략될 때</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Fraction</span> <span class="nf">fr_copy2</span><span class="p">(</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎
Constructor
</code></pre></div></div>

<ul>
  <li><em>Fraction fr_copy2(<strong>Fraction(3, 10)</strong>);</em>
    <ul>
      <li>인수로 넘겨진 <strong>Fraction(3, 10)</strong>은 <u>익명 객체</u>다.
        <ul>
          <li>R-value로서 임시적으로 잠깐 자리를 차지했다가 사라지는.</li>
        </ul>
      </li>
      <li>직관적으로 생각해보면 Fraction(3, 10)이 생성되면서 Constructor가 출력되고 <strong>이 익명 객체를 fr_copy2에 복사하면서</strong> Copy Constructor도 호출되야 하는데
        <ul>
          <li>즉 이 한번의 실행에 <u>생성자</u>, <u>복사생성자</u>가 둘 다 호출되야 하는데</li>
        </ul>
      </li>
      <li><strong><u>복사 생성자는 호출되지 않고 Fraction(3, 10) 생성시 호출된 일반 생성자만 호출된다.</u></strong>
        <ul>
          <li>
            <blockquote>
              <p>복사 과정이 생략 되었기 때문이다.</p>
            </blockquote>
            <ul>
              <li>컴파일러는 불필요하게 생성자가 많이 호출되는 것을 방지하기 위해 복사 생성을 수행하지 않고 <code class="language-plaintext highlighter-rouge">fr_copy2</code> 자체를 <code class="language-plaintext highlighter-rouge">Fraction(3, 10)</code>로 만들어 버린다.
                <ul>
                  <li>즉 복사 과정 없이 그냥 <code class="language-plaintext highlighter-rouge">fr_copy2</code>가 곧 <code class="language-plaintext highlighter-rouge">Fraction(3, 10)</code> 메모리를 참조하게 된다.
                    <ul>
                      <li><code class="language-plaintext highlighter-rouge">fr_copy2</code> 와 <code class="language-plaintext highlighter-rouge">Fraction(3, 10)</code>는 주소 동일.</li>
                    </ul>
                  </li>
                  <li><code class="language-plaintext highlighter-rouge">Fraction(3, 10)</code> 메모리는 <code class="language-plaintext highlighter-rouge">fr_copy2</code>가 되었으므로 사라지지 않는다.
                    <ul>
                      <li>익명 객체는 원래 바로 사라지지만 자신(메모리)를 참조해주는 변수가 생겼으므로 사라지지 않음</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><img src="https://user-images.githubusercontent.com/42318591/86194926-b5e84300-bb8a-11ea-9ab4-b9f43e437795.png" alt="image" width="70%" height="70%" class="align-center" /></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>이처럼 복사할 대상이 R-value 객체일 때 컴파일러가 복사 과정을 생략하기도 한다.</p>
</blockquote>

<ul>
  <li>복사 대상이 리턴받은 객체일 때, 위의 예시처럼 익명 객체일 때 등등</li>
  <li>복사 과정을 생략할지는 컴파일러가 판단한다. (항상 생략하는 것은 아니라고 한다.)
    <ul>
      <li>C++ 17 부터는 함수 내부에서 객체를 만들어 리턴하는 경우 등등 일부 경우에 대해서는 반드시 복사를 생략한다고 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="복사-생성자-호출을-막고-싶을-때">복사 생성자 호출을 막고 싶을 때</h3>

<blockquote>
  <p>복사 생성자를 <code class="language-plaintext highlighter-rouge">private</code>영역에 정의 해버리면 호출되지 않는다.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">private:</span>
    <span class="n">Fraction</span><span class="p">(</span><span class="k">const</span> <span class="n">Fraction</span> <span class="o">&amp;</span><span class="n">fraction</span><span class="p">)</span>  <span class="c1">// copy constructor</span>
	<span class="o">:</span><span class="n">m_numerator</span><span class="p">(</span><span class="n">fraction</span><span class="p">.</span><span class="n">m_numerator</span><span class="p">),</span> <span class="n">m_denominator</span><span class="p">(</span><span class="n">fraction</span><span class="p">.</span><span class="n">m_denominator</span><span class="p">)</span>
    <span class="p">{</span> 
	    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
    <span class="p">}</span>

<span class="p">...</span>

<span class="n">Fraction</span> <span class="nf">f</span><span class="p">(</span><span class="n">frac</span><span class="p">);</span>  <span class="c1">// 복사 생성자 호출 안됨</span>
<span class="n">Fraction</span> <span class="n">f</span> <span class="o">=</span> <span class="n">frac</span><span class="p">;</span> <span class="c1">// 복사 생성자 호출 안됨</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="-리턴값-최적화">🔔 리턴값 최적화</h2>

<p><a href="#복사-과정이-생략될-때">“복사 과정이 생략될 때” 문단</a>과 연관된다.</p>

<blockquote>
  <p>임시 객체를 함수로 리턴받고 이를 복사 대상으로 삼을 때</p>
</blockquote>

<ul>
  <li><strong>디버그 모드</strong> 👉 복사를 하며 복사 생성자가 호출된다.</li>
  <li><strong>릴리즈 모드</strong> 👉 복사를 생략하며 복사 생성자가 호출되지 않는다.
    <ul>
      <li>최적화를 위하여!</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Fraction</span> <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Fraction</span> <span class="n">temp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Fraction</span> <span class="n">result</span> <span class="o">=</span> <span class="n">doSomething</span><span class="p">();</span>  <span class="c1">// 👈👈👈</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>doSomething() 함수는 임시 객체 temp를 리턴하는데 이는 지역 범위이므로 리턴 후 사라진다.</li>
  <li><strong>디버그 모드</strong>
    <ul>
      <li>복사 과정이 생략되지 않는다.
        <ul>
          <li>복사 생성자가 호출된다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">&amp;temp</code>와 <code class="language-plaintext highlighter-rouge">&amp;result</code> 값은 다르다.
        <ul>
          <li>주소가 다르다. 즉 별개의 메모리다.</li>
          <li><code class="language-plaintext highlighter-rouge">temp</code>가 <code class="language-plaintext highlighter-rouge">result</code>에 복사되었다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">temp</code>는 임시 객체이므로 복사된 후 사라진다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>릴리즈 모드</strong>
    <ul>
      <li>최적화를 위해 컴파일러가 복사 과정을 생략한다.
        <ul>
          <li>복사 생성자가 호출되지 않는다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">&amp;temp</code>와 <code class="language-plaintext highlighter-rouge">&amp;result</code> 값은 동일하다.
        <ul>
          <li>주소가 같다. 즉 동일한 메모리다.</li>
          <li><code class="language-plaintext highlighter-rouge">temp</code>가 <code class="language-plaintext highlighter-rouge">result</code>에 복사되지 않고 <code class="language-plaintext highlighter-rouge">result</code>가 곧 <code class="language-plaintext highlighter-rouge">temp</code>메모리가 되었다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>

<p><br /></p>
:ET