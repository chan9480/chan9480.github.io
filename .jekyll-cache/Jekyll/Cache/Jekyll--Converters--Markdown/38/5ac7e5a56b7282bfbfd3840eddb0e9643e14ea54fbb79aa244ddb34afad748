I"$G<p class="notice--warning"><strong>아래 함수들을 사용하기 위해선 <u>원소들이 정렬되어 있다는 전제가 있어야 한다.</u></strong></p>

<h2 id="-lower_bound">🚀 <code class="language-plaintext highlighter-rouge">lower_bound</code></h2>

<blockquote>
  <p>어떤 값의 <u>하한선</u></p>
</blockquote>

<ul>
  <li><strong>이진 참색의 방법</strong>으로 어떤 값의 하한선을 찾는다.</li>
  <li><em>lower_bound(v.begin(), v.end(), 150)</em>
    <ul>
      <li>👉 <code class="language-plaintext highlighter-rouge">v</code> 컨테이너에서 Key : <code class="language-plaintext highlighter-rouge">150</code> 과 <u>일치하면 그 Key의 반복자를 리턴하고 </u>, 일치 하는게 없다면 <code class="language-plaintext highlighter-rouge">150</code>을 <u>초과하는 것 중 가장 작은 것</u>의 반복자를 리턴한다.</li>
    </ul>
  </li>
  <li>[1, 10, 20, 40, 50, 60, 70]
    <ul>
      <li><code class="language-plaintext highlighter-rouge">50</code>을 lower_bound 로 찾는다면 <code class="language-plaintext highlighter-rouge">50</code>의 반복자 리턴</li>
      <li><code class="language-plaintext highlighter-rouge">65</code>을 lower_bound 로 찾는다면 <code class="language-plaintext highlighter-rouge">65</code>는 없으므로 <code class="language-plaintext highlighter-rouge">70</code>의 반복자 리턴</li>
      <li><code class="language-plaintext highlighter-rouge">80</code>을 lower_bound 로 찾는다면 없으므로 <code class="language-plaintext highlighter-rouge">end()</code> 리턴</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lower</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">myVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myVector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">7</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>두 반복자로 나타낸 해당 범위 안의 원소들 중 <u>세번째 인수 값보다 <u>크거나 같은</u> 첫번째 원소의 반복자를 리턴</u>한다.
    <ul>
      <li>없다면 범위의 끝을 나타내는 반복자를 리턴한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">sort</code>와 마찬가지로 비교를 위한 비교 함수 포인터도 인자로 넣어줄 수 있다.</li>
  <li>예시
    <ul>
      <li>arr = [1, 2, 3, 4, 5, 6, 7] 일때</li>
      <li><code class="language-plaintext highlighter-rouge">lower_bound(arr, arr + 10, 6)</code>은 <code class="language-plaintext highlighter-rouge">6을 가리키는 반복자</code> 이다.
        <ul>
          <li>6 보다 크거나 같은 첫번째 원소는 6</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="-lower_bound-를-직접-구현한-코드">🔥 <code class="language-plaintext highlighter-rouge">lower_bound</code> 를 직접 구현한 코드</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
 
<span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>  
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>    
 
    <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>  
<span class="p">}</span>

<span class="k">return</span> <span class="n">end</span><span class="p">;</span> <span class="c1">// 시작 위치 == 끝 위치가 되면 빠져 나오며 이 위치가 바로 답이 된다. </span>
</code></pre></div></div>

<ul>
  <li>Key 보다 <em>작은</em> 범위는 답이 될 수 없다. 👉 <em>start = mid + 1</em></li>
  <li>Key 보다 <em>크거나 같은</em> 범위는 답이 될 수 있다. 그러므로 현재의 <code class="language-plaintext highlighter-rouge">mid</code>가 또 답 후보가 될 수 있다. 👉 <em>end = mid</em>
    <ul>
      <li>lower_bound 는 일치하는 것도 답이 될 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="-lower_bound-에-원하는-정렬-기준-적용하기">🔥 <code class="language-plaintext highlighter-rouge">lower_bound</code> 에 원하는 정렬 기준 적용하기</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">lower_bound</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">start</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span> <span class="c1">// comp 비교함수 기준으로 답을 찾게 됨</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lower_bound</code>는 크기 비교를 통하여 이진 탐색으로 답을 도출하는데, 이 크기 비교 즉 정렬 기준 또한 원하는대로 적용할 수 있다. <u>sort 함수에 비교 함수 적용해주듯이 비교함수 적용해주면 된다!</u></p>

<p>위 코드를 예로 들면 1 순위로 문자열 길이를 기준으로 정렬하고 2 순위로 사전 순서로 정렬하는 비교 함수를 만들어 이를 <code class="language-plaintext highlighter-rouge">lower_bound</code>에 적용한 모습이다. 이제 <code class="language-plaintext highlighter-rouge">lower_bound</code> 는 사전 순서로 비교하기에 앞서 길이가 더 짧은 것이 더 작다고 판단하고 답을 찾게 될 것이다.</p>

<p>예를 들어 위 비교 함수를 적용시킨다면 이제 <code class="language-plaintext highlighter-rouge">lower_bound</code>는 “zzz” 가 “abcde” 보다 값이 작다고 판단할 것이다. 길이 비교가 더 우선되기 때문이다!</p>

<p><br /></p>

<h2 id="-upper_bound">🚀 <code class="language-plaintext highlighter-rouge">upper_bound</code></h2>

<blockquote>
  <p>어떤 값의 <u>상한선</u></p>
</blockquote>

<ul>
  <li><strong>이진 참색의 방법</strong>으로 어떤 값의 상한선을 찾는다.</li>
  <li><em>lower_bound(v.begin(), v.end(), 150)</em>
    <ul>
      <li>👉 <code class="language-plaintext highlighter-rouge">v</code> 컨테이너에서 <code class="language-plaintext highlighter-rouge">150</code>을 <u>초과하는 것 중 가장 작은 것</u>의 반복자를 리턴한다.</li>
      <li><strong>uppder_bound 는 lower_bound 와는 다르게 일치하는건 찾지 않는다.</strong>
        <ul>
          <li>lower_bound 👉 일치 or 초과하는 것 중 가장 작은 것</li>
          <li>upper_bound 👉 초과하는 것 중 가장 작은 것</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>[1, 10, 20, 40, 50, 60, 70]
    <ul>
      <li><code class="language-plaintext highlighter-rouge">50</code>을 upper_bound 로 찾는다면 <code class="language-plaintext highlighter-rouge">60</code>의 반복자 리턴 👉 <u>lower_bound 와의 차이!</u></li>
      <li><code class="language-plaintext highlighter-rouge">65</code>을 upper_bound 로 찾는다면 <code class="language-plaintext highlighter-rouge">70</code>의 반복자 리턴</li>
      <li><code class="language-plaintext highlighter-rouge">80</code>을 upper_bound 로 찾는다면 없으므로 <code class="language-plaintext highlighter-rouge">end()</code> 리턴</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upper</span> <span class="o">=</span> <span class="n">upper_bound</span><span class="p">(</span><span class="n">myVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myVector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">7</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>두 반복자로 나타낸 해당 범위 안의 원소들 중 <u>세번째 인수 값보다 <u>큰</u> 첫번째 원소의 반복자를 리턴</u>한다.
    <ul>
      <li>없다면 범위의 끝을 나타내는 반복자를 리턴한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">sort</code>와 마찬가지로 비교를 위한 비교 함수 포인터도 인자로 넣어줄 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="-upper_bound-를-직접-구현한-코드">🔥 <code class="language-plaintext highlighter-rouge">upper_bound</code> 를 직접 구현한 코드</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
 
<span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)){</span>  
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>    
 
    <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">key</span><span class="p">)</span> <span class="c1">// ⭐lower_bound랑 다른점은 여기뿐!!!!!</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>  
<span class="p">}</span>

<span class="k">return</span> <span class="n">end</span><span class="p">;</span> <span class="c1">// 시작 위치 == 끝 위치가 되면 빠져 나오며 이 위치가 바로 답이 된다. </span>
</code></pre></div></div>

<ul>
  <li>Key 보다 <em>작거나 같은</em> 범위는 답이 될 수 없다. 👉 <em>start = mid + 1</em>
    <ul>
      <li>uppder_bound 는 lower_bound 와 다르게 일치하는 것은 답이 될 수 없음</li>
    </ul>
  </li>
  <li>Key 보다 <em>큰</em> 범위는 답이 될 수 있다. 그러므로 현재의 <code class="language-plaintext highlighter-rouge">mid</code>가 또 답 후보가 될 수 있다. 👉 <em>end = mid</em></li>
</ul>

<p><br /></p>

<h3 id="-upper_bound-에-원하는-정렬-기준-적용하기">🔥 <code class="language-plaintext highlighter-rouge">upper_bound</code> 에 원하는 정렬 기준 적용하기</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upper_bound</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">start</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lower_bound</code>와 똑같이 정의한 비교함수 파라미터로 넘겨주면 됨.</p>

<p><br /></p>

<h2 id="-equal_range">🚀 equal_range</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">lower_bound</code> 와 <code class="language-plaintext highlighter-rouge">uppder_bound</code> 를 같이 묶어 리턴해줌</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">equal_range</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><u>(lowerbound, uppderbound)</u>의 <code class="language-plaintext highlighter-rouge">std::pair</code> 객체를 리턴한다.
    <ul>
      <li>(해당 범위 내에서 처음으로 3과 같거나 큰 원소의 반복자, 해당 범위 내에서 처음으로 3보다큰 원소의 반복자)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="-binary_search">🚀 binary_search</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이렇게 구현되어 있다.</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ForwardIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">binary_search</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">first</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">first</span><span class="o">!=</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">val</span><span class="o">&lt;*</span><span class="n">first</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">binary_search</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bool</code>타입을 리턴한다.
    <ul>
      <li>즉 세번째 인수가 해당 범위 내에 있다면 true, 없으면 false를 리턴한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="-binary_search-에-원하는-정렬-기준-적용하기">🔥 <code class="language-plaintext highlighter-rouge">binary_search</code> 에 원하는 정렬 기준 적용하기</h3>

<p>비교 함수를 파라미터로 넘기면 된다.</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET