I",<p class="notice--warning">인프런에 있는 홍정모 교수님의 <strong>홍정모의 따라 하며 배우는 C++</strong> 강의를 듣고 정리한 필기입니다. 😀  <br />
<a href="https://www.inflearn.com/course/following-c-plus">🌜 [홍정모의 따라 하며 배우는 C++]강의 들으러 가기!</a></p>

<p><br /></p>

<h1 id="chapter-12-가상-함수들--가상-함수와-다형성">chapter 12. 가상 함수들 : 가상 함수와 다형성</h1>

<h2 id="-virtual-유무의-차이">🔔 <code class="language-plaintext highlighter-rouge">virtual</code> 유무의 차이</h2>

<h3 id="가상함수-안-썼을-때">가상함수 안 썼을 때</h3>

<ul>
  <li>D가 C를 상속하고, C는 B를 상속하고, B는 A를 상속하는 구조</li>
  <li>A의 대대 손손 자손들인 B, C, D는 모두 <em>print()</em>를 오버라이딩 하고 있다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"D"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">B</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">C</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">D</span> <span class="n">d</span><span class="p">;</span>

    <span class="n">A</span> <span class="o">&amp;</span><span class="n">ref1</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">ref1</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>  <span class="c1">// "A" 출력</span>

	<span class="n">C</span> <span class="o">&amp;</span><span class="n">ref2</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">ref2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>  <span class="c1">// "C" 출력</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>C++은 참조하거나 가리키는 객체의 타입이 아니라, <u>참조하는 **변수 혹은 포인터의 타입**이 무엇이냐에 따라 멤버를 호출</u>하기 때문에
    <ul>
      <li>B타입 객체인 b를 참조하고 있더라도 <em>ref1</em>은 A타입이기 때문에 <em>ref1.print();</em> A의 print()을 호출한다.</li>
      <li>D타입 객체인 d를 참조하고 있더라도 <em>ref2</em>은 C타입이기 때문에 <em>ref2.print();</em> C의 print()을 호출한다.</li>
    </ul>
  </li>
</ul>

<h3 id="가상함수-썼을-때">가상함수 썼을 때</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"D"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">B</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">C</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">D</span> <span class="n">d</span><span class="p">;</span>

    <span class="n">A</span> <span class="o">&amp;</span><span class="n">ref1</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">ref1</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>  <span class="c1">// "C" 출력</span>

	<span class="n">C</span> <span class="o">&amp;</span><span class="n">ref2</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">ref2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>  <span class="c1">// "D" 출력</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>가상 함수 <code class="language-plaintext highlighter-rouge">virtual</code></p>
</blockquote>

<ol>
  <li><code class="language-plaintext highlighter-rouge">virtual</code> 가상 함수로 지정된 함수를 호출할 땐, <strong><em>원래의 C++과 반대로</em></strong>, 변수가 아닌 참조하는 <u>객체의 타입이 무엇이냐에 따라 호출한다.</u>
    <ul>
      <li>즉, <u>부모 포인터로 호출하더라도 자식이 오버라이딩한 함수를 호출한다.</u></li>
      <li><strong>ref1.print();</strong> print()는 가상함수이므로 ref1은 C타입 객체인 c를 참조하기 때문에 C에서 오버라이딩된 print()를 호출한다. ref2도 마찬가지!</li>
    </ul>
  </li>
  <li>조상 클래스 <code class="language-plaintext highlighter-rouge">virtual</code> 가상 함수는 대대손손 유지된다.
    <ul>
      <li>따라서 조상클래스의 가상함수를 자손 클래스들에게 물려주어도 <u>자식 클래스에서 virtual을 붙여 주지 않더라도 그대로 가상함수다.</u></li>
      <li>A 클래스의 print()에만 virtual을 붙여도 B, C, D에서 오버라이딩 한 print()들도 모두 가상 함수라는 특성이 유지된다.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">A</span>
  <span class="p">{</span>
  <span class="nl">public:</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">};</span>
</code></pre></div>        </div>
      </li>
      <li>이렇게 <code class="language-plaintext highlighter-rouge">virtual</code>속성 또한 대대손손 상속이 되기 때문에 C타입인 <em>ref2</em>로 print()를 호출하더라도 참조하는 객체의 타입인 D타입의 print()를 호출한다.</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h2 id="-주의사항">🔔 주의사항</h2>

<ol>
  <li>오버라이딩 할 땐 <u>리턴까입까지도 꼭 같아야한다.</u>
    <ul>
      <li>오버로딩시엔 리턴타입은 고려대상이 아니지만.</li>
    </ul>
  </li>
  <li>virtual 가상 함수는 스택처럼 쌓아서 처리되는게 아니라 <u>가상함수표</u>를 사용하여 조상으로 찾아 올라가는 식이라 <strong>좀 느리다.</strong></li>
</ol>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a>
<br /></p>
:ET