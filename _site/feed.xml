<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-03T20:43:39+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">배우자 그리고 써먹자</title><subtitle>포트폴리오</subtitle><author><name>옹달샘👱</name></author><entry><title type="html">openCV 이미지 읽기</title><link href="http://localhost:4000/ds/3rd/" rel="alternate" type="text/html" title="openCV 이미지 읽기" /><published>2021-11-18T00:00:00+09:00</published><updated>2022-02-03T00:00:00+09:00</updated><id>http://localhost:4000/ds/3rd</id><content type="html" xml:base="http://localhost:4000/ds/3rd/"><![CDATA[<h2 id="opencv-vs-pillowpil-vs-scikit-image">OpenCV vs pillow(PIL) vs scikit-image</h2>
<blockquote>
  <p>https://github.com/ethereon/lycon<br />
위 링크에서는 세 라이브러리의 속도비교를 해 놓았는데,<br />
속도측이나 기능측이나 빠르 openCV를 사용한 이미지 읽기를 정리해보려한다.<br />
만약 다른 라이블리르 이용할 일이 생길때마다 업데이트를 해야겠다.</p>
</blockquote>

<h2 id="opencv-설치">openCV 설치</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda install -c anaconda opencv
</code></pre></div></div>

<h2 id="local-경로로-이미지열기">local 경로로 이미지열기</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import cv2
cv2.imread('파일경로', flags) # ndarray형식으로 리턴.
</code></pre></div></div>
<blockquote>
  <p>flags 는 컬러 (3차원)가 default, 숫자 0 을 넣으면 흑백(1차원)</p>
</blockquote>

<h2 id="링크이미지jpeg-열기">링크이미지(.jpeg) 열기</h2>
<blockquote>
  <p>크롤링의 개념을 가져와서 사용한다.
````
import cv2
from google.colab.patches import cv2_imshow
import numpy as np
import urllib.request</p>
</blockquote>

<p>def url_to_image(url):
  ‘’’
  jpg, png 이미지링크에서 numpy ndarray로 return
  ‘’’
  resp = urllib.request.urlopen(url)
  image = np.asarray(bytearray(resp.read()), dtype=’uint8’)
  image = cv2.imdecode(image, cv2.IMREAD_COLOR)</p>

<p>return image</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; requests.urlopen : url 에서 request(응답) 객체르 리턴  
&gt; -&gt; .read()로써 호출할 수 있음.  
&gt; numpy.asarray : 배열로써 이미지르 읽음
&gt; image를 cv2로 다시 읽어 리턴한다.(3차원)  

## svg 파일 열기
&gt; cairosvg 라이브러리 내 함수, svg2png, svg2pdf, svg2svg, svg2ps 등 지원    
&gt; m1 mac에서는 어떻게 설치하는 업데이트 할 예정 아직공부중
## 이미지 확인하기  
</code></pre></div></div>
<p>img = 이미지의 ndarray형식
cv2.imshow(‘name’, img)   # name은 이미지르 띄운 window 이름
````</p>
<blockquote>
  <p>위는 주피터노트북에서 쓰면 되느 방식이고 .py르 터미널에서 실행할때는<br />
cv2.waitKey(0) 을 이용해서 키보드입력이 있을때까지 띄워놓아야 한다!<br />
cv2.destroyAllWindows() 또한 띄워놓으 윈도우르 전부 파괴</p>
</blockquote>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>옹달샘👱</name></author><category term="ds" /><category term="Image" /><category term="OpenCV" /><summary type="html"><![CDATA[OpenCV vs pillow(PIL) vs scikit-image https://github.com/ethereon/lycon 위 링크에서는 세 라이브러리의 속도비교를 해 놓았는데, 속도측이나 기능측이나 빠르 openCV를 사용한 이미지 읽기를 정리해보려한다. 만약 다른 라이블리르 이용할 일이 생길때마다 업데이트를 해야겠다. openCV 설치 conda install -c anaconda opencv local 경로로 이미지열기 import cv2 cv2.imread('파일경로', flags) # ndarray형식으로 리턴. flags 는 컬러 (3차원)가 default, 숫자 0 을 넣으면 흑백(1차원) 링크이미지(.jpeg) 열기 크롤링의 개념을 가져와서 사용한다. ```` import cv2 from google.colab.patches import cv2_imshow import numpy as np import urllib.request def url_to_image(url): ‘’’ jpg, png 이미지링크에서 numpy ndarray로 return ‘’’ resp = urllib.request.urlopen(url) image = np.asarray(bytearray(resp.read()), dtype=’uint8’) image = cv2.imdecode(image, cv2.IMREAD_COLOR) return image &gt; requests.urlopen : url 에서 request(응답) 객체르 리턴 &gt; -&gt; .read()로써 호출할 수 있음. &gt; numpy.asarray : 배열로써 이미지르 읽음 &gt; image를 cv2로 다시 읽어 리턴한다.(3차원) ## svg 파일 열기 &gt; cairosvg 라이브러리 내 함수, svg2png, svg2pdf, svg2svg, svg2ps 등 지원 &gt; m1 mac에서는 어떻게 설치하는 업데이트 할 예정 아직공부중 ## 이미지 확인하기 img = 이미지의 ndarray형식 cv2.imshow(‘name’, img) # name은 이미지르 띄운 window 이름 ```` 위는 주피터노트북에서 쓰면 되느 방식이고 .py르 터미널에서 실행할때는 cv2.waitKey(0) 을 이용해서 키보드입력이 있을때까지 띄워놓아야 한다! cv2.destroyAllWindows() 또한 띄워놓으 윈도우르 전부 파괴 🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄 맨 위로 이동하기]]></summary></entry><entry><title type="html">진짜 시작 그리고 m1맥북 세팅</title><link href="http://localhost:4000/something_else/setting/" rel="alternate" type="text/html" title="진짜 시작 그리고 m1맥북 세팅" /><published>2021-11-16T00:00:00+09:00</published><updated>2022-02-03T00:00:00+09:00</updated><id>http://localhost:4000/something_else/setting</id><content type="html" xml:base="http://localhost:4000/something_else/setting/"><![CDATA[<h2 id="반성">반성</h2>
<p>지난 6월 코드스테이츠를 시작하면서 블로그를 개설했는데 꾸준히 쓰겠다고 했는데,<br />
꾸준히는 개뿔 이게 테스트용 첫번째 글 이후 이게 5개월만에 두번째 글을 올리게 되었다.</p>

<h2 id="왜-필요성을-느꼈는가">왜 필요성을 느꼈는가</h2>
<p>사실 대학교를 다닐때도 기록보단 필기를 하였고, 시험공부를 위한 필기였기에 그 필요성을 느끼지 못하다가<br />
이번에 section4 딥러닝 파트를 마무리하면서 그 필요성을 느끼게 되었다.<br />
그 전환점으로 지난 2년간 쓴 아이폰에 용기를 얻어 맥북을 구매하면서, 개발세팅을 새로하게되었는데<br />
m1 칩셋을 사용하다보니 세팅하는게 하나하나가 쉽지 않았다.<br />
그와 동시에 이 과정들을 기록해두지 않으면 다시 찾아봐야한다는 공포가 엄습했고<br />
이를 계기로 맥북을 사용하여 지금까지 해온 코드스테이츠<br />
<strong>전체적인 복습</strong> 과<br />
<strong>완성하지 못한 section 4 프로젝트를 마무리하는 과정을 불로깅</strong> <br />
하는게 1차 목표다.</p>

<h2 id="터미널-창-띄우기">터미널 창 띄우기</h2>
<blockquote>
  <p>cmd + space를 눌러 spotlight에서 ‘터미널’을 검색하면 된다.</p>
</blockquote>

<h2 id="맥북-m1-세팅">맥북 m1 세팅</h2>
<h3 id="homebrew-설치">homebrew 설치</h3>
<blockquote>
  <p>macOS용 패키지 관리 어플리케이션!
https://brew.sh
위 공식 홈페이지를 참고한다면 어렵지 않게 설치가능하다.<br />
단, m1의 경우 ㅜㅜ finder에서 터미널 어플을 찾아 우클릭하여 ‘정보가져오기’에서 ‘rossetta로 사용하여 열기’를 꼭! 체크해야한다.<br />
로제타는 기존의 intel 프로세서에서 돌아가는 친구들을 m1 칩셋, 즉 apple silicon에서 돌아가게 변환해주는 에뮬이라고 보면 된다.</p>
</blockquote>

<h3 id="miniforge-설치">miniforge 설치</h3>
<blockquote>
  <p>알아보니 아나콘다를 설치안하고 miniforge만 설치해도 되는거였다.. m1에서 conda 를 좀더 에러없게 실행하는 인스톨러이며, anaconda와 동급의 카테고리다.
(conda의 인스톨러 종류 : 아나콘다, miniforge, miniconda) 이렇게<br />
https://developer.apple.com/metal/tensorflow-plugin/<br />
위에서 apple silicon 이라되어있는곳을 따라 진행하면 된다 ( 설치파일 받고 아래 코드 3줄)</p>

  <p>(brew install miniforge 로 설치해주면 된다고도 하는데 tensorfolw-deps (의존성)설치에서 에러가나더라)</p>
</blockquote>

<h3 id="아나콘다-가상환경-생성-삭제-패키지-설치">아나콘다 가상환경 생성, 삭제, 패키지 설치</h3>
<blockquote>
  <p>생성</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda create --name 이름 python=3.8
</code></pre></div>  </div>
  <p>삭제</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda env remove --namve 이름
</code></pre></div>  </div>
</blockquote>

<h3 id="git-설치">git 설치</h3>
<blockquote>
  <p>git에 기능이 많겠지만 본인은, github 레포와 연동하여 프로젝트들을 관리하기 위한 용도이다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    brew install git
</code></pre></div>  </div>
  <p>만으로 설치가 가능하다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git --version
</code></pre></div>  </div>
  <p>으로 확인까지!</p>
</blockquote>

<h1 id="가상환경-세팅">가상환경 세팅</h1>
<h3 id="m1-tensorflow-gpu사용하기">m1 tensorflow-gpu사용하기</h3>
<blockquote>
  <p>m1은 gpu까지 하나로 싸잡아서 만든 칩셋이라 설정방법도 다르다..
가상환경에서</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda install -c apple tensorflow-deps
    pip install tensorflow-macos
    pip install tensorflow-metal
</code></pre></div>  </div>
  <p>로 설치해준다.
파이썬 내에서</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    import tensorflow as tf
    print(len(tf.config.experimental.list_physical_devices('GPU')))
</code></pre></div>  </div>
  <p>위 결과가 1이 나오면 사용할 수 있다.
단, 확인을 했으면 아래와같이 tensorflow 2.0을 사용하자.(혹시모르니)</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    import tensorflow.compat.v2 as tf
</code></pre></div>  </div>
  <h3 id="jupyter-notebook과-pandas-설치">jupyter notebook과 pandas 설치</h3>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda install -c conda-forge -y pandas jupyter
</code></pre></div>  </div>
  <p>로 설치해준다. pandas 필요없다면 pandas나 jupyter만 지우면 된다.</p>
  <h3 id="그-외-패키지-설치">그 외 패키지 설치</h3>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda install 패키지이름
</code></pre></div>  </div>
  <p>단,conda 명령어로 설치가 되는지 안되는지는 잘 검색해보고 쓰는게 좋다. (pip으로만 설치가 되는 패키지도 있음)</p>
</blockquote>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>옹달샘👱</name></author><category term="Something_else" /><category term="setting" /><category term="M1" /><summary type="html"><![CDATA[반성 지난 6월 코드스테이츠를 시작하면서 블로그를 개설했는데 꾸준히 쓰겠다고 했는데, 꾸준히는 개뿔 이게 테스트용 첫번째 글 이후 이게 5개월만에 두번째 글을 올리게 되었다. 왜 필요성을 느꼈는가 사실 대학교를 다닐때도 기록보단 필기를 하였고, 시험공부를 위한 필기였기에 그 필요성을 느끼지 못하다가 이번에 section4 딥러닝 파트를 마무리하면서 그 필요성을 느끼게 되었다. 그 전환점으로 지난 2년간 쓴 아이폰에 용기를 얻어 맥북을 구매하면서, 개발세팅을 새로하게되었는데 m1 칩셋을 사용하다보니 세팅하는게 하나하나가 쉽지 않았다. 그와 동시에 이 과정들을 기록해두지 않으면 다시 찾아봐야한다는 공포가 엄습했고 이를 계기로 맥북을 사용하여 지금까지 해온 코드스테이츠 전체적인 복습 과 완성하지 못한 section 4 프로젝트를 마무리하는 과정을 불로깅 하는게 1차 목표다. 터미널 창 띄우기 cmd + space를 눌러 spotlight에서 ‘터미널’을 검색하면 된다. 맥북 m1 세팅 homebrew 설치 macOS용 패키지 관리 어플리케이션! https://brew.sh 위 공식 홈페이지를 참고한다면 어렵지 않게 설치가능하다. 단, m1의 경우 ㅜㅜ finder에서 터미널 어플을 찾아 우클릭하여 ‘정보가져오기’에서 ‘rossetta로 사용하여 열기’를 꼭! 체크해야한다. 로제타는 기존의 intel 프로세서에서 돌아가는 친구들을 m1 칩셋, 즉 apple silicon에서 돌아가게 변환해주는 에뮬이라고 보면 된다. miniforge 설치 알아보니 아나콘다를 설치안하고 miniforge만 설치해도 되는거였다.. m1에서 conda 를 좀더 에러없게 실행하는 인스톨러이며, anaconda와 동급의 카테고리다. (conda의 인스톨러 종류 : 아나콘다, miniforge, miniconda) 이렇게 https://developer.apple.com/metal/tensorflow-plugin/ 위에서 apple silicon 이라되어있는곳을 따라 진행하면 된다 ( 설치파일 받고 아래 코드 3줄) (brew install miniforge 로 설치해주면 된다고도 하는데 tensorfolw-deps (의존성)설치에서 에러가나더라) 아나콘다 가상환경 생성, 삭제, 패키지 설치 생성 conda create --name 이름 python=3.8 삭제 conda env remove --namve 이름 git 설치 git에 기능이 많겠지만 본인은, github 레포와 연동하여 프로젝트들을 관리하기 위한 용도이다. brew install git 만으로 설치가 가능하다. git --version 으로 확인까지! 가상환경 세팅 m1 tensorflow-gpu사용하기 m1은 gpu까지 하나로 싸잡아서 만든 칩셋이라 설정방법도 다르다.. 가상환경에서 conda install -c apple tensorflow-deps pip install tensorflow-macos pip install tensorflow-metal 로 설치해준다. 파이썬 내에서 import tensorflow as tf print(len(tf.config.experimental.list_physical_devices('GPU'))) 위 결과가 1이 나오면 사용할 수 있다. 단, 확인을 했으면 아래와같이 tensorflow 2.0을 사용하자.(혹시모르니) import tensorflow.compat.v2 as tf jupyter notebook과 pandas 설치 conda install -c conda-forge -y pandas jupyter 로 설치해준다. pandas 필요없다면 pandas나 jupyter만 지우면 된다. 그 외 패키지 설치 conda install 패키지이름 단,conda 명령어로 설치가 되는지 안되는지는 잘 검색해보고 쓰는게 좋다. (pip으로만 설치가 되는 패키지도 있음) 🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄 맨 위로 이동하기]]></summary></entry><entry><title type="html">test게시물</title><link href="http://localhost:4000/example_sub/test/" rel="alternate" type="text/html" title="test게시물" /><published>2020-08-29T00:00:00+09:00</published><updated>2020-08-29T00:00:00+09:00</updated><id>http://localhost:4000/example_sub/test</id><content type="html" xml:base="http://localhost:4000/example_sub/test/"><![CDATA[<h2 id="test_제목">test_제목</h2>
<p>test 게시물입니다.</p>

<h2 id="test_제목-2">test_제목 2</h2>
<p>test2 목차 테스트 입니다.</p>

<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>옹달샘👱</name></author><category term="Example_sub" /><category term="Test" /><category term="Test_2" /><summary type="html"><![CDATA[test_제목 test 게시물입니다.]]></summary></entry><entry><title type="html">파이썬, 자료구조</title><link href="http://localhost:4000/something_else/4th/" rel="alternate" type="text/html" title="파이썬, 자료구조" /><published>2020-08-29T00:00:00+09:00</published><updated>2020-08-29T00:00:00+09:00</updated><id>http://localhost:4000/something_else/4th</id><content type="html" xml:base="http://localhost:4000/something_else/4th/"><![CDATA[<h2 id="서론">서론</h2>
<blockquote>
  <p>옛날에 RTOS관련 대학원에 진학해보려 했다가 받은 질문중에 하나가 스택과 큐의 차이점과 예시를 설명하라는 내용이었다.<br />
스택은 쌓아놓은 책을 위에서 부터 다시꺼낸다면 큐는 만화책 반납통같이 위에서 넣으면 밑에서 꺼내는 개념이라고 말씀드렸다.
물론 틀린건 아니지만 지금 생각해보면 그냥 얘는 개념만 알고 실사용은 해보지 않은 친구라고 생각하셨을 것 같다.
오늘 각각을 구현해보면서 이해해보는 시간을 가졌다.</p>
</blockquote>

<h2 id="큐queue-를-연결리스트로-구현">큐(queue) 를 연결리스트로 구현</h2>
<blockquote>
  <p>연결리스트<br />
<img src="https://user-images.githubusercontent.com/84547813/143422364-4784b7ad-46c9-48d0-9420-3a1d24d85e37.png" alt="image" />
큐  <br />
<img src="https://user-images.githubusercontent.com/84547813/143422687-a1fd91a0-2fe0-495a-a014-63f2b08096d8.png" alt="image" /></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Node():
    def __init__(self, data):
        self._data = data
        self._next = None
</code></pre></div></div>
<blockquote>
  <p>node 들을 선언했다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Queue():
    def __init__(self):
        self._front = None
        self._rear = None
</code></pre></div>  </div>
  <p>‘맨앞’ (꺼내는곳) 와 ‘맨뒤’ (넣는곳) 자리를 마련했다. 큐를 들여다볼수 있는 창문 두개라고 비유하여 이해했다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    def enqueue(self,item):
        new_node = Node(item)
        if self._front == None: # 빈 큐 라면 '맨앞' '맨뒤'에 모두 같은 노드를 넣어준당.
            self._front = new_node
            self._rear = self._front
        else: # 뭔가 있는 큐라면 뒤의 노드에 대해서만 새로운 노드를 연결해주면 된다.
            self._rear._next = new_node           #기존 '맨뒤노드'의 next에 새로운 노드를 넣어준당. (연결!)
            self._rear = self._rear._next         #큐의 '맨뒤' 에 새로운 노드를 위치시킨당. (맨뒤 업데이트!)
</code></pre></div>  </div>
  <p>값 item을 큐에 추가하는 함수를 정의했다. (내부에서는 item을 value로 갖는 node를 연결해준것)</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    def dequeue(self):
        if self._front == None: # 빈큐라면 None을 리턴
            return None
        else : #뭔가 있는 큐라면 맨앞에서 뽑은 값 리턴 + '맨앞' 업데이트
            temp = self._front._data       # '맨앞'노드의 데이터를 잠깐 빼두자.
            self._front = self._front._next  #'맨앞' 노드의 next 에 있는 노드를 큐의 '맨앞'으로 둔다.
        if self._front ==None:
            # 이렇게 되는 경우는 1개짜리의 큐에서 dequeue를 진행한 후가 될거다.
            self._rear = None           #그러면 '맨뒤'도 비워주자 (이거 안하면 '맨뒤'에 꺼낸 노드가 아직 남아있음)
        return temp
</code></pre></div>  </div>
  <p>빈큐라면 None을 리턴, 빈큐가 아니라면 제일 먼저 넣은 하나를 큐에서 제거하는 함수를 정의했다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    def return_queue(self):
        result = []
        temp = self._front      # 초기값은 '맨앞' node!
        while temp!= None:      # temp에 None이 들어가버리면 다 끝난거다!
            result.append(temp._data)
            temp = temp._next   # temp에는 그 다음 node 넣장. (None이 들어갈수도 있음 그러면 loop끝)
        return result
</code></pre></div>  </div>
  <p>현재 큐를 list로 리턴하는 함수를 정의했다.</p>
</blockquote>

<h2 id="스택stack을-list로-구현">스택(stack)을 list로 구현</h2>
<blockquote>
  <p>스택의 경우 넣는곳과 빼는곳이 같은 자료구조이다.<br />
그런데 파이썬에서는 list의경우 list.append(x) 와 list.pop() 으로 구현이 가능하다.<br />
(물론 큐도 가능하다. 그러나 pop(0)를 사용하여야 하는데, 그렇게 되면 리스트 끝에서부터 index 0 의 방향으로 탐색을 하기때문에, 비효율적이다.)  <br />
<img src="https://user-images.githubusercontent.com/84547813/143422784-8eec4149-9d71-46b8-b76e-47da8dac1d63.png" alt="image" /></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Stack():
    def __init__(self):
        self._data = []

    def push(self, item):
        self._data.append(item)


    def pop(self):
        return self._data.pop() if self._data else None


    def return_stack(self):
        return self._data
</code></pre></div></div>
<blockquote>
  <p>간단해서 코드 리뷰는 생략했다.</p>
  <h2 id="데크-구현">데크 구현</h2>
  <p>동작은 하는데, pop에서 비효율적으로 탐색하는 부분이 있다.(top에써 꺼낼라해도 bottom부터 탐색을 해야하는 부분)
양방향 연결리스트로 수정을 해서 업데이트를 해야겠다<br />
https://user-images.githubusercontent.com/84547813/143423521-f8877649-559d-4a49-aa82-c6f69335bd04.png</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Node:
    def __init__(self, value, next=None):
        self.value = value
        self.next = next

class Deque:
    def __init__(self):
        self.top = None
        self.bottom = None


    def append(self, item):
        if self.top == None:        # self.top이 비어있다면
            self.top = Node(item)   # self.top 에도 bottom에도 뉴 노드를 넣어준다.
            self.bottom = self.top
        else :
            node = Node(item)
            self.top.next = node    # 현재 top의 next에 뉴 노드를 넣어주고
            self.top = node         # 이제 top은 뉴 노드로 한다.


    def appendleft(self, item):
        node = Node(item)
        if self.bottom == None :        # bottom이 비었다면 top, bottom에 둘다 넣어줘
            self.top = node
            self.bottom = node
        else :
            node.next = self.bottom     # 뉴 노드의 next 를 bottom으로 설정 후, 앞으로 bottom은 뉴노드다!
            self.bottom = node

</code></pre></div></div>
<blockquote>
  <p>top 방향과 bottom방향에 값을 추가할 수 있는 함수 두개를 정의했다.
````
    def pop(self):
        # top 추출
        if self.top == None:        # top이 None 이면 return None
            return None
        elif self.top == self.bottom:   # top과 bottom이 같다면(None은 아님)
            result = self.top.value     # value를 리턴하고, top bottom을 비우자 (None)
            self.top =None
            self.bottom = None
            return result
        else :                          # 이제 정상적으로 길이 1이상의 데크라면
            node = self.bottom          # 초기값 bottom부터 next가 top인 곳까지 node를 찾아서
            result = self.top.value     # (리턴값은 어쨋든 top value)
            while node !=None:          # top을 업데이트해주자.
                if node.next == self.top:
                    self.top = node
                node = node.next
            return result</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def popleft(self):
    # bottom 추출
    if self.bottom == None:
        return None
    elif self.top == self.bottom:
        self.top = None
        result = self.bottom.value
        self.bottom = None
        return result
    else :
        result = self.bottom.value
        self.bottom = self.bottom.next
        return result ```` &gt; top에서 추출하는 pop과 bottom에서 추출하는 popleft를 정의했다. ````

def ord_desc(self):
    node = self.bottom      # 초기값은 bottom 부터
    result = []
    while node != None :    # 노드에 None이 들어있다면 종료
        result.append(node.value)
        node = node.next
    return result ```` &gt; 현재 데크를 리스트로 리턴하는 함수를 정의했다.
</code></pre></div></div>]]></content><author><name>옹달샘👱</name></author><category term="Something_else" /><category term="algorithm" /><category term="data_structure" /><summary type="html"><![CDATA[서론 옛날에 RTOS관련 대학원에 진학해보려 했다가 받은 질문중에 하나가 스택과 큐의 차이점과 예시를 설명하라는 내용이었다. 스택은 쌓아놓은 책을 위에서 부터 다시꺼낸다면 큐는 만화책 반납통같이 위에서 넣으면 밑에서 꺼내는 개념이라고 말씀드렸다. 물론 틀린건 아니지만 지금 생각해보면 그냥 얘는 개념만 알고 실사용은 해보지 않은 친구라고 생각하셨을 것 같다. 오늘 각각을 구현해보면서 이해해보는 시간을 가졌다. 큐(queue) 를 연결리스트로 구현 연결리스트 큐 class Node(): def __init__(self, data): self._data = data self._next = None node 들을 선언했다. class Queue(): def __init__(self): self._front = None self._rear = None ‘맨앞’ (꺼내는곳) 와 ‘맨뒤’ (넣는곳) 자리를 마련했다. 큐를 들여다볼수 있는 창문 두개라고 비유하여 이해했다. def enqueue(self,item): new_node = Node(item) if self._front == None: # 빈 큐 라면 '맨앞' '맨뒤'에 모두 같은 노드를 넣어준당. self._front = new_node self._rear = self._front else: # 뭔가 있는 큐라면 뒤의 노드에 대해서만 새로운 노드를 연결해주면 된다. self._rear._next = new_node #기존 '맨뒤노드'의 next에 새로운 노드를 넣어준당. (연결!) self._rear = self._rear._next #큐의 '맨뒤' 에 새로운 노드를 위치시킨당. (맨뒤 업데이트!) 값 item을 큐에 추가하는 함수를 정의했다. (내부에서는 item을 value로 갖는 node를 연결해준것) def dequeue(self): if self._front == None: # 빈큐라면 None을 리턴 return None else : #뭔가 있는 큐라면 맨앞에서 뽑은 값 리턴 + '맨앞' 업데이트 temp = self._front._data # '맨앞'노드의 데이터를 잠깐 빼두자. self._front = self._front._next #'맨앞' 노드의 next 에 있는 노드를 큐의 '맨앞'으로 둔다. if self._front ==None: # 이렇게 되는 경우는 1개짜리의 큐에서 dequeue를 진행한 후가 될거다. self._rear = None #그러면 '맨뒤'도 비워주자 (이거 안하면 '맨뒤'에 꺼낸 노드가 아직 남아있음) return temp 빈큐라면 None을 리턴, 빈큐가 아니라면 제일 먼저 넣은 하나를 큐에서 제거하는 함수를 정의했다. def return_queue(self): result = [] temp = self._front # 초기값은 '맨앞' node! while temp!= None: # temp에 None이 들어가버리면 다 끝난거다! result.append(temp._data) temp = temp._next # temp에는 그 다음 node 넣장. (None이 들어갈수도 있음 그러면 loop끝) return result 현재 큐를 list로 리턴하는 함수를 정의했다. 스택(stack)을 list로 구현 스택의 경우 넣는곳과 빼는곳이 같은 자료구조이다. 그런데 파이썬에서는 list의경우 list.append(x) 와 list.pop() 으로 구현이 가능하다. (물론 큐도 가능하다. 그러나 pop(0)를 사용하여야 하는데, 그렇게 되면 리스트 끝에서부터 index 0 의 방향으로 탐색을 하기때문에, 비효율적이다.) class Stack(): def __init__(self): self._data = [] def push(self, item): self._data.append(item) def pop(self): return self._data.pop() if self._data else None def return_stack(self): return self._data 간단해서 코드 리뷰는 생략했다. 데크 구현 동작은 하는데, pop에서 비효율적으로 탐색하는 부분이 있다.(top에써 꺼낼라해도 bottom부터 탐색을 해야하는 부분) 양방향 연결리스트로 수정을 해서 업데이트를 해야겠다 https://user-images.githubusercontent.com/84547813/143423521-f8877649-559d-4a49-aa82-c6f69335bd04.png class Node: def __init__(self, value, next=None): self.value = value self.next = next class Deque: def __init__(self): self.top = None self.bottom = None def append(self, item): if self.top == None: # self.top이 비어있다면 self.top = Node(item) # self.top 에도 bottom에도 뉴 노드를 넣어준다. self.bottom = self.top else : node = Node(item) self.top.next = node # 현재 top의 next에 뉴 노드를 넣어주고 self.top = node # 이제 top은 뉴 노드로 한다. def appendleft(self, item): node = Node(item) if self.bottom == None : # bottom이 비었다면 top, bottom에 둘다 넣어줘 self.top = node self.bottom = node else : node.next = self.bottom # 뉴 노드의 next 를 bottom으로 설정 후, 앞으로 bottom은 뉴노드다! self.bottom = node top 방향과 bottom방향에 값을 추가할 수 있는 함수 두개를 정의했다. ```` def pop(self): # top 추출 if self.top == None: # top이 None 이면 return None return None elif self.top == self.bottom: # top과 bottom이 같다면(None은 아님) result = self.top.value # value를 리턴하고, top bottom을 비우자 (None) self.top =None self.bottom = None return result else : # 이제 정상적으로 길이 1이상의 데크라면 node = self.bottom # 초기값 bottom부터 next가 top인 곳까지 node를 찾아서 result = self.top.value # (리턴값은 어쨋든 top value) while node !=None: # top을 업데이트해주자. if node.next == self.top: self.top = node node = node.next return result def popleft(self): # bottom 추출 if self.bottom == None: return None elif self.top == self.bottom: self.top = None result = self.bottom.value self.bottom = None return result else : result = self.bottom.value self.bottom = self.bottom.next return result ```` &gt; top에서 추출하는 pop과 bottom에서 추출하는 popleft를 정의했다. ```` def ord_desc(self): node = self.bottom # 초기값은 bottom 부터 result = [] while node != None : # 노드에 None이 들어있다면 종료 result.append(node.value) node = node.next return result ```` &gt; 현재 데크를 리스트로 리턴하는 함수를 정의했다.]]></summary></entry></feed>