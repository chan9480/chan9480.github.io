<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="kr-KR"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="kr-KR" /><updated>2022-01-28T05:56:17-05:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Data is Power</title><author><name>박찬우</name></author><entry><title type="html">선형회귀</title><link href="http://localhost:4000/6th/" rel="alternate" type="text/html" title="선형회귀" /><published>2022-01-21T00:00:00-05:00</published><updated>2022-01-21T00:00:00-05:00</updated><id>http://localhost:4000/6th</id><content type="html" xml:base="http://localhost:4000/6th/"><![CDATA[<h2 id="선형회귀">선형회귀</h2>
<blockquote>
  <p>엑셀에서 점들의 추세선을 그어본적이 있다. 거기서 R값을 표시할 수도 있었는데, 이게 단순 선형회귀의 예시가 아닌가 싶다.<br />
이 또한, 머신러닝이다. 특정 평가지표가 최소가 되도록 모델에 학습데이터를 fit을 시켜주는 데, 평가지표의 종류는 아래와 같다.<br />
y는 실제값(관측값, 측정값)     y^는 예측값 즉 ax+b, y평균은 y전체의 평균.<br />
<img width="677" alt="image" src="https://user-images.githubusercontent.com/84547813/150494749-1be8815a-3e36-416c-9ff7-62370f5c540f.png" /></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 라이브러리 import
from sklearn.linear_model import LinearRegression

# 데이터 정의
df = '타겟을 포함한 데이터 프레임'
df_test = '타겟 미포함 "테스트" 데이터 프레임'

# 모델 클래스 정의
model = LinearRegression()

# feature, target 정의
feature = ['feature_name']
target = ['target_name']
X_train = df[feature]
y_train = df[target]

# 모델 학습
model.fit(X_train, y_train)

# 예측값.
X_test = [[x] for x in df_test['feature_name']]
y_pred = model.predict(X_test)

# 계수확인
print('절편', model.intercept_)
print('계수(여러개일 수 있기때문에 array)', model.coef_)

# 시각화.
import matplotlib.pyplot as plt
## train 데이터에 대한 그래프를 검정색 점으로.
plt.scatter(X_train, y_train, color='black', linewidth=1)

## test 데이터에 대한 예측을 파란색 점으로.
plt.scatter(X_test, y_pred, color='blue', linewidth=1);
</code></pre></div></div>

<h2 id="다중선형회귀">다중선형회귀</h2>
<blockquote>
  <p>x에 대해서 y의 추세선을 그으면 단순선형회귀, x와 y에 대해서 z의 추세선을 그으면 다중선형회귀가 될 것이다.(혹은 x1, x2 에 대하 y일 수도 있겠다.)<br />
그렇다면 4개이상 n개의 특성(feature)에 대해서 target의 추세선을 그릴 수 있을까?<br />
위 평가지표(MSE, MAE, R square)에서 예측값 y^ 는 ax+b일수도 있지만 ax+bw+c의 형태로도 될 수있고 일반화하면 아래와 같다.<br />
<img width="102" alt="image" src="https://user-images.githubusercontent.com/84547813/150503177-644087c1-f1a0-4bb3-bc41-203cb552d7ec.png" /></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 라이브러리 import
from sklearn.linear_model import LinearRegression

# 데이터 정의
df = '타겟을 포함한 데이터 프레임'
df_test = '타겟 미포함 "테스트" 데이터 프레임'

# 모델 클래스 정의
model = LinearRegression()

# feature, target 정의
feature = ['feature_name_1', 'feature_name_2 ]
target = ['target_name']
X_train = df[feature]
y_train = df[target]

# 모델 학습
model.fit(X_train, y_train)

# 예측값.
X_test = df_test[feature]
y_pred = model.predict(X_test)

# 계수확인
print('절편', model.intercept_)
print('계수(여러개일 수 있기때문에 array)', model.coef_)
</code></pre></div></div>

<h2 id="평가지표">평가지표</h2>]]></content><author><name>박찬우</name></author><category term="linear regression" /><summary type="html"><![CDATA[단순선형회귀, 다중선형회귀, 릿지회귀, 퀵정렬, 병합정렬]]></summary></entry><entry><title type="html">정렬</title><link href="http://localhost:4000/5th/" rel="alternate" type="text/html" title="정렬" /><published>2021-11-27T00:00:00-05:00</published><updated>2021-11-27T00:00:00-05:00</updated><id>http://localhost:4000/5th</id><content type="html" xml:base="http://localhost:4000/5th/"><![CDATA[<h2 id="선택정렬">선택정렬</h2>
<blockquote>
  <blockquote>
    <p>제일 작은걸 차례대로 찾아서, 맨앞부터 계속 교체해주는 정렬.<br />
n개에 대해서 교환을 하며, 그 과정에서 최솟값을 찾기위해 n번 비교<br />
(비교대상이 1씩 줄긴하지만 n이 최고차항이긴함.)를 하므로 O(n^2)<br />
<img src="https://user-images.githubusercontent.com/84547813/145223514-1b92d47c-4204-4890-8ab3-07af49e0894b.png" alt="image" /></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def selection_sort(li):
    n = len(li)
    for i in range(n):      # i번쨰가 주체
        for j in range(i,n):# i번째 뒤로 쭉
            if li[i] &gt; li[j]:
                li[i], li[j] = li[j], li[i]     # 교환
            else :
                pass
    return li
</code></pre></div>    </div>
    <h2 id="삽입정렬">삽입정렬</h2>
    <p>순서대로 자리를 찾아서 끼워 넣어주는 정렬<br />
n개에 대해서 하며, 최악의 경우 탐색을 계속 n개에 대해 길게하게 되기때문에 O(n^2)<br />
아래 사진은 31의 자리를 찾아 넣어주고있다.<br />
<img src="https://user-images.githubusercontent.com/84547813/145224534-3f5b9130-8641-48b6-9151-53a91695617f.png" alt="image" /></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def insertion_sort(li):
    n=len(li)
    if n ==0:
        return None
    for i in range(1,n): # 두번째부터 끝까지 수행하면 댐.
        temp = li[i]
        for j in range(i-1, -1 , -1): # i-1부터 0까지 비교를 해야댐.
            if li[j] &gt; temp:
                li[j+1] = li[j]       # j에서 temp보다 크다면 옆으로복사
                if j==0:              # 그와중에 0에 도착햇다면 그냥 0(맨앞)에 temp대입
                    li[0] = temp
            else:
                li[j+1] = temp        # j보다 temp가 크다면 그 오른쪽에 temp넣고 break
                break
    return li
</code></pre></div>    </div>
    <h2 id="버블정렬">버블정렬</h2>
    <p>계속해서 옆과 비교,교환을 하는 방식.<br />
(오름차순에서) 만약 맨앞에 제일큰숫자가 있다면, 끊임없이 교환을 거듭하여 끝까지 갈 것이다.(n번)<br />
그 과정을 (1번부터 n까지), (1번부터 n-1까지) … (1과 2) 반복하면 (n번) O(n^2)이다.<br />
<img src="https://user-images.githubusercontent.com/84547813/145225965-b9c07b7f-44b5-438e-9d6b-487b99eb5863.png" alt="image" /></p>
  </blockquote>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def bubble_sort(li):
    n = len(li)
    for i in range(n):      # 0부터 n-1까지
        for j in range(0,n-i):# j는 항상 0부터이되, n-i까지만반복
            if j==(n-1):      # indexError 방지.
                pass
            elif li[j] &gt; li[j+1]:
                li[j], li[j+1] = li[j+1], li[j]     # 교환
            else :
                pass
    return li   
</code></pre></div></div>
<h2 id="퀵정렬">퀵정렬</h2>
<blockquote>
  <blockquote>
    <p>특정값을 잡아 그보다 큰값과 작은값으로 계속해서 반으로 쪼갠다 1개짜리 리스트가 될때까지.<br />
이상적으로 쪼개어진다면 아래그림에서 한층에 대해 모든수를 비교하므로 n , 그 층은 2^x의 해 이므로 log n 이므로 O(nlogn) <br />
<img src="https://user-images.githubusercontent.com/84547813/145229539-66ac03f9-ff21-451a-b60d-262e8b4d09ca.png" alt="image" /><br />
그러나 아래처럼 계속 최악의 경우로 된다면 층은 n층이 되기때문에 최악의 경우 O(n^2) 
<img src="https://user-images.githubusercontent.com/84547813/145229599-9731477a-81d1-4bda-9e28-3ca1a4e62241.png" alt="image" /></p>
  </blockquote>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def quick_sort(li):
    if len(li)&lt;=1:
        return li
    else:
        L1, L2 = [], []
        for x in li[1:]:
            if x&lt;=li[0]:
                L1.append(x)
            else :
                L2.append(x)
        return quick_sort( L1 ) + quick_sort([ li[0] ]) + quick_sort( L2 )
</code></pre></div></div>
<h2 id="병합정렬">병합정렬</h2>]]></content><author><name>박찬우</name></author><category term="sort" /><category term="python" /><summary type="html"><![CDATA[선택정렬, 삽입정렬, 버블정렬, 퀵정렬, 병합정렬]]></summary></entry><entry><title type="html">파이썬, 자료구조</title><link href="http://localhost:4000/4th/" rel="alternate" type="text/html" title="파이썬, 자료구조" /><published>2021-11-25T00:00:00-05:00</published><updated>2021-11-25T00:00:00-05:00</updated><id>http://localhost:4000/4th</id><content type="html" xml:base="http://localhost:4000/4th/"><![CDATA[<h2 id="서론">서론</h2>
<blockquote>
  <p>옛날에 RTOS관련 대학원에 진학해보려 했다가 받은 질문중에 하나가 스택과 큐의 차이점과 예시를 설명하라는 내용이었다.<br />
스택은 쌓아놓은 책을 위에서 부터 다시꺼낸다면 큐는 만화책 반납통같이 위에서 넣으면 밑에서 꺼내는 개념이라고 말씀드렸다.
물론 틀린건 아니지만 지금 생각해보면 그냥 얘는 개념만 알고 실사용은 해보지 않은 친구라고 생각하셨을 것 같다.
오늘 각각을 구현해보면서 이해해보는 시간을 가졌다.</p>
</blockquote>

<h2 id="큐queue-를-연결리스트로-구현">큐(queue) 를 연결리스트로 구현</h2>
<blockquote>
  <p>연결리스트<br />
<img src="https://user-images.githubusercontent.com/84547813/143422364-4784b7ad-46c9-48d0-9420-3a1d24d85e37.png" alt="image" />
큐  <br />
<img src="https://user-images.githubusercontent.com/84547813/143422687-a1fd91a0-2fe0-495a-a014-63f2b08096d8.png" alt="image" /></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Node():
    def __init__(self, data):
        self._data = data
        self._next = None
</code></pre></div></div>
<blockquote>
  <p>node 들을 선언했다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Queue():
    def __init__(self):
        self._front = None
        self._rear = None
</code></pre></div>  </div>
  <p>‘맨앞’ (꺼내는곳) 와 ‘맨뒤’ (넣는곳) 자리를 마련했다. 큐를 들여다볼수 있는 창문 두개라고 비유하여 이해했다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    def enqueue(self,item):
        new_node = Node(item)
        if self._front == None: # 빈 큐 라면 '맨앞' '맨뒤'에 모두 같은 노드를 넣어준당.
            self._front = new_node
            self._rear = self._front
        else: # 뭔가 있는 큐라면 뒤의 노드에 대해서만 새로운 노드를 연결해주면 된다.
            self._rear._next = new_node           #기존 '맨뒤노드'의 next에 새로운 노드를 넣어준당. (연결!)
            self._rear = self._rear._next         #큐의 '맨뒤' 에 새로운 노드를 위치시킨당. (맨뒤 업데이트!)
</code></pre></div>  </div>
  <p>값 item을 큐에 추가하는 함수를 정의했다. (내부에서는 item을 value로 갖는 node를 연결해준것)</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    def dequeue(self):
        if self._front == None: # 빈큐라면 None을 리턴
            return None
        else : #뭔가 있는 큐라면 맨앞에서 뽑은 값 리턴 + '맨앞' 업데이트
            temp = self._front._data       # '맨앞'노드의 데이터를 잠깐 빼두자.
            self._front = self._front._next  #'맨앞' 노드의 next 에 있는 노드를 큐의 '맨앞'으로 둔다.
        if self._front ==None:
            # 이렇게 되는 경우는 1개짜리의 큐에서 dequeue를 진행한 후가 될거다.
            self._rear = None           #그러면 '맨뒤'도 비워주자 (이거 안하면 '맨뒤'에 꺼낸 노드가 아직 남아있음)
        return temp
</code></pre></div>  </div>
  <p>빈큐라면 None을 리턴, 빈큐가 아니라면 제일 먼저 넣은 하나를 큐에서 제거하는 함수를 정의했다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    def return_queue(self):
        result = []
        temp = self._front      # 초기값은 '맨앞' node!
        while temp!= None:      # temp에 None이 들어가버리면 다 끝난거다!
            result.append(temp._data)
            temp = temp._next   # temp에는 그 다음 node 넣장. (None이 들어갈수도 있음 그러면 loop끝)
        return result
</code></pre></div>  </div>
  <p>현재 큐를 list로 리턴하는 함수를 정의했다.</p>
</blockquote>

<h2 id="스택stack을-list로-구현">스택(stack)을 list로 구현</h2>
<blockquote>
  <p>스택의 경우 넣는곳과 빼는곳이 같은 자료구조이다.<br />
그런데 파이썬에서는 list의경우 list.append(x) 와 list.pop() 으로 구현이 가능하다.<br />
(물론 큐도 가능하다. 그러나 pop(0)를 사용하여야 하는데, 그렇게 되면 리스트 끝에서부터 index 0 의 방향으로 탐색을 하기때문에, 비효율적이다.)  <br />
<img src="https://user-images.githubusercontent.com/84547813/143422784-8eec4149-9d71-46b8-b76e-47da8dac1d63.png" alt="image" /></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Stack():
    def __init__(self):
        self._data = []

    def push(self, item):
        self._data.append(item)


    def pop(self):
        return self._data.pop() if self._data else None


    def return_stack(self):
        return self._data
</code></pre></div></div>
<blockquote>
  <p>간단해서 코드 리뷰는 생략했다.</p>
  <h2 id="데크-구현">데크 구현</h2>
  <p>동작은 하는데, pop에서 비효율적으로 탐색하는 부분이 있다.(top에써 꺼낼라해도 bottom부터 탐색을 해야하는 부분)
양방향 연결리스트로 수정을 해서 업데이트를 해야겠다<br />
https://user-images.githubusercontent.com/84547813/143423521-f8877649-559d-4a49-aa82-c6f69335bd04.png</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Node:
    def __init__(self, value, next=None):
        self.value = value
        self.next = next

class Deque:
    def __init__(self):
        self.top = None
        self.bottom = None


    def append(self, item):
        if self.top == None:        # self.top이 비어있다면
            self.top = Node(item)   # self.top 에도 bottom에도 뉴 노드를 넣어준다.
            self.bottom = self.top
        else :
            node = Node(item)
            self.top.next = node    # 현재 top의 next에 뉴 노드를 넣어주고
            self.top = node         # 이제 top은 뉴 노드로 한다.


    def appendleft(self, item):
        node = Node(item)
        if self.bottom == None :        # bottom이 비었다면 top, bottom에 둘다 넣어줘
            self.top = node
            self.bottom = node
        else :
            node.next = self.bottom     # 뉴 노드의 next 를 bottom으로 설정 후, 앞으로 bottom은 뉴노드다!
            self.bottom = node

</code></pre></div></div>
<blockquote>
  <p>top 방향과 bottom방향에 값을 추가할 수 있는 함수 두개를 정의했다.
````
    def pop(self):
        # top 추출
        if self.top == None:        # top이 None 이면 return None
            return None
        elif self.top == self.bottom:   # top과 bottom이 같다면(None은 아님)
            result = self.top.value     # value를 리턴하고, top bottom을 비우자 (None)
            self.top =None
            self.bottom = None
            return result
        else :                          # 이제 정상적으로 길이 1이상의 데크라면
            node = self.bottom          # 초기값 bottom부터 next가 top인 곳까지 node를 찾아서 
            result = self.top.value     # (리턴값은 어쨋든 top value)
            while node !=None:          # top을 업데이트해주자.
                if node.next == self.top:
                    self.top = node
                node = node.next
            return result</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def popleft(self):
    # bottom 추출
    if self.bottom == None:
        return None
    elif self.top == self.bottom:
        self.top = None
        result = self.bottom.value
        self.bottom = None
        return result
    else :
        result = self.bottom.value
        self.bottom = self.bottom.next
        return result ```` &gt; top에서 추출하는 pop과 bottom에서 추출하는 popleft를 정의했다. ````

def ord_desc(self):
    node = self.bottom      # 초기값은 bottom 부터
    result = []
    while node != None :    # 노드에 None이 들어있다면 종료
        result.append(node.value)
        node = node.next
    return result ```` &gt; 현재 데크를 리스트로 리턴하는 함수를 정의했다.
</code></pre></div></div>]]></content><author><name>박찬우</name></author><category term="python" /><category term="data structure" /><summary type="html"><![CDATA[연결리스트, 스택(stack), 큐(queue), 데크(deque)]]></summary></entry><entry><title type="html">openCV 이미지 읽기</title><link href="http://localhost:4000/3rd/" rel="alternate" type="text/html" title="openCV 이미지 읽기" /><published>2021-11-18T00:00:00-05:00</published><updated>2021-11-18T00:00:00-05:00</updated><id>http://localhost:4000/3rd</id><content type="html" xml:base="http://localhost:4000/3rd/"><![CDATA[<h2 id="opencv-vs-pillowpil-vs-scikit-image">OpenCV vs pillow(PIL) vs scikit-image</h2>
<blockquote>
  <p>https://github.com/ethereon/lycon<br />
위 링크에서는 세 라이브러리의 속도비교를 해 놓았는데,<br />
속도측이나 기능측이나 빠르 openCV를 사용한 이미지 읽기를 정리해보려한다.<br />
만약 다른 라이블리르 이용할 일이 생길때마다 업데이트를 해야겠다.</p>
</blockquote>

<h2 id="opencv-설치">openCV 설치</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda install -c anaconda opencv
</code></pre></div></div>

<h2 id="local-경로로-이미지열기">local 경로로 이미지열기</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import cv2
cv2.imread('파일경로', flags) # ndarray형식으로 리턴.
</code></pre></div></div>
<blockquote>
  <p>flags 는 컬러 (3차원)가 default, 숫자 0 을 넣으면 흑백(1차원)</p>
</blockquote>

<h2 id="링크이미지jpeg-열기">링크이미지(.jpeg) 열기</h2>
<blockquote>
  <p>크롤링의 개념을 가져와서 사용한다.
````
import cv2
from google.colab.patches import cv2_imshow
import numpy as np
import urllib.request</p>
</blockquote>

<p>def url_to_image(url):
  ‘’’
  jpg, png 이미지링크에서 numpy ndarray로 return
  ‘’’
  resp = urllib.request.urlopen(url)
  image = np.asarray(bytearray(resp.read()), dtype=’uint8’)
  image = cv2.imdecode(image, cv2.IMREAD_COLOR)</p>

<p>return image</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; requests.urlopen : url 에서 request(응답) 객체르 리턴  
&gt; -&gt; .read()로써 호출할 수 있음.  
&gt; numpy.asarray : 배열로써 이미지르 읽음
&gt; image를 cv2로 다시 읽어 리턴한다.(3차원)  
  
## svg 파일 열기
&gt; cairosvg 라이브러리 내 함수, svg2png, svg2pdf, svg2svg, svg2ps 등 지원    
&gt; m1 mac에서는 어떻게 설치하는 업데이트 할 예정 아직공부중
## 이미지 확인하기  
</code></pre></div></div>
<p>img = 이미지의 ndarray형식
cv2.imshow(‘name’, img)   # name은 이미지르 띄운 window 이름
````</p>
<blockquote>
  <p>위는 주피터노트북에서 쓰면 되느 방식이고 .py르 터미널에서 실행할때는<br />
cv2.waitKey(0) 을 이용해서 키보드입력이 있을때까지 띄워놓아야 한다!<br />
cv2.destroyAllWindows() 또한 띄워놓으 윈도우르 전부 파괴</p>
</blockquote>]]></content><author><name>박찬우</name></author><category term="image" /><category term="openCV" /><summary type="html"><![CDATA[openCV, 링크이미지 열기, svg파일]]></summary></entry><entry><title type="html">진짜 시작 그리고 m1맥북 세팅</title><link href="http://localhost:4000/2nd/" rel="alternate" type="text/html" title="진짜 시작 그리고 m1맥북 세팅" /><published>2021-11-16T00:00:00-05:00</published><updated>2021-11-16T00:00:00-05:00</updated><id>http://localhost:4000/2nd</id><content type="html" xml:base="http://localhost:4000/2nd/"><![CDATA[<h2 id="반성">반성</h2>
<p>지난 6월 코드스테이츠를 시작하면서 블로그를 개설했는데 꾸준히 쓰겠다고 했는데,<br />
꾸준히는 개뿔 이게 테스트용 첫번째 글 이후 이게 5개월만에 두번째 글을 올리게 되었다.</p>

<h2 id="왜-필요성을-느꼈는가">왜 필요성을 느꼈는가</h2>
<p>사실 대학교를 다닐때도 기록보단 필기를 하였고, 시험공부를 위한 필기였기에 그 필요성을 느끼지 못하다가<br />
이번에 section4 딥러닝 파트를 마무리하면서 그 필요성을 느끼게 되었다.<br />
그 전환점으로 지난 2년간 쓴 아이폰에 용기를 얻어 맥북을 구매하면서, 개발세팅을 새로하게되었는데<br />
m1 칩셋을 사용하다보니 세팅하는게 하나하나가 쉽지 않았다.<br />
그와 동시에 이 과정들을 기록해두지 않으면 다시 찾아봐야한다는 공포가 엄습했고<br />
이를 계기로 맥북을 사용하여 지금까지 해온 코드스테이츠<br />
<strong>전체적인 복습</strong> 과<br />
<strong>완성하지 못한 section 4 프로젝트를 마무리하는 과정을 불로깅</strong> <br />
하는게 1차 목표다.</p>

<h2 id="터미널-창-띄우기">터미널 창 띄우기</h2>
<blockquote>
  <p>cmd + space를 눌러 spotlight에서 ‘터미널’을 검색하면 된다.</p>
</blockquote>

<h2 id="맥북-m1-세팅">맥북 m1 세팅</h2>
<h3 id="homebrew-설치">homebrew 설치</h3>
<blockquote>
  <p>macOS용 패키지 관리 어플리케이션!
https://brew.sh
위 공식 홈페이지를 참고한다면 어렵지 않게 설치가능하다.<br />
단, m1의 경우 ㅜㅜ finder에서 터미널 어플을 찾아 우클릭하여 ‘정보가져오기’에서 ‘rossetta로 사용하여 열기’를 꼭! 체크해야한다.<br />
로제타는 기존의 intel 프로세서에서 돌아가는 친구들을 m1 칩셋, 즉 apple silicon에서 돌아가게 변환해주는 에뮬이라고 보면 된다.</p>
</blockquote>

<h3 id="miniforge-설치">miniforge 설치</h3>
<blockquote>
  <p>알아보니 아나콘다를 설치안하고 miniforge만 설치해도 되는거였다.. m1에서 conda 를 좀더 에러없게 실행하는 인스톨러이며, anaconda와 동급의 카테고리다.
(conda의 인스톨러 종류 : 아나콘다, miniforge, miniconda) 이렇게<br />
https://developer.apple.com/metal/tensorflow-plugin/<br />
위에서 apple silicon 이라되어있는곳을 따라 진행하면 된다 ( 설치파일 받고 아래 코드 3줄)</p>

  <p>(brew install miniforge 로 설치해주면 된다고도 하는데 tensorfolw-deps (의존성)설치에서 에러가나더라)</p>
</blockquote>

<h3 id="아나콘다-가상환경-생성-삭제-패키지-설치">아나콘다 가상환경 생성, 삭제, 패키지 설치</h3>
<blockquote>
  <p>생성</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda create --name 이름 python=3.8
</code></pre></div>  </div>
  <p>삭제</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda env remove --namve 이름
</code></pre></div>  </div>
</blockquote>

<h3 id="git-설치">git 설치</h3>
<blockquote>
  <p>git에 기능이 많겠지만 본인은, github 레포와 연동하여 프로젝트들을 관리하기 위한 용도이다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    brew install git
</code></pre></div>  </div>
  <p>만으로 설치가 가능하다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git --version
</code></pre></div>  </div>
  <p>으로 확인까지!</p>
</blockquote>

<h1 id="가상환경-세팅">가상환경 세팅</h1>
<h3 id="m1-tensorflow-gpu사용하기">m1 tensorflow-gpu사용하기</h3>
<blockquote>
  <p>m1은 gpu까지 하나로 싸잡아서 만든 칩셋이라 설정방법도 다르다..
가상환경에서</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda install -c apple tensorflow-deps
    pip install tensorflow-macos
    pip install tensorflow-metal
</code></pre></div>  </div>
  <p>로 설치해준다.
파이썬 내에서</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    import tensorflow as tf
    print(len(tf.config.experimental.list_physical_devices('GPU')))
</code></pre></div>  </div>
  <p>위 결과가 1이 나오면 사용할 수 있다.
단, 확인을 했으면 아래와같이 tensorflow 2.0을 사용하자.(혹시모르니)</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    import tensorflow.compat.v2 as tf
</code></pre></div>  </div>
  <h3 id="jupyter-notebook과-pandas-설치">jupyter notebook과 pandas 설치</h3>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda install -c conda-forge -y pandas jupyter
</code></pre></div>  </div>
  <p>로 설치해준다. pandas 필요없다면 pandas나 jupyter만 지우면 된다.</p>
  <h3 id="그-외-패키지-설치">그 외 패키지 설치</h3>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    conda install 패키지이름
</code></pre></div>  </div>
  <p>단,conda 명령어로 설치가 되는지 안되는지는 잘 검색해보고 쓰는게 좋다. (pip으로만 설치가 되는 패키지도 있음)</p>
</blockquote>]]></content><author><name>박찬우</name></author><category term="setting" /><summary type="html"><![CDATA[homebrew, miniforge, git ,tensorflow-gpu, pandas, jupyter notebook]]></summary></entry><entry><title type="html">블로그 만든 날</title><link href="http://localhost:4000/test/first/" rel="alternate" type="text/html" title="블로그 만든 날" /><published>2021-06-30T00:00:00-04:00</published><updated>2021-06-30T00:00:00-04:00</updated><id>http://localhost:4000/test/first</id><content type="html" xml:base="http://localhost:4000/test/first/"><![CDATA[<h1 id="블로그-만든-날">블로그 만든 날.</h1>

<p>앞으로 꾸준히 업로드 할 예정</p>]]></content><author><name>박찬우</name></author><category term="test" /><category term="test" /><summary type="html"><![CDATA[첫 게시물]]></summary></entry><entry><title type="html">test_post</title><link href="http://localhost:4000/edge%20case/edge-case-many-tags/" rel="alternate" type="text/html" title="test_post" /><published>2009-06-01T00:00:00-04:00</published><updated>2009-06-01T00:00:00-04:00</updated><id>http://localhost:4000/edge%20case/edge-case-many-tags</id><content type="html" xml:base="http://localhost:4000/edge%20case/edge-case-many-tags/"><![CDATA[<p>This post has many tags.</p>]]></content><author><name>박찬우</name></author><category term="Edge Case" /><category term="8BIT" /><category term="alignment" /><category term="Articles" /><category term="captions" /><category term="categories" /><category term="chat" /><category term="comments" /><category term="content" /><category term="css" /><category term="dowork" /><category term="edge case" /><category term="embeds" /><category term="excerpt" /><category term="Fail" /><category term="featured image" /><category term="FTW" /><category term="Fun" /><category term="gallery" /><category term="html" /><category term="image" /><category term="Jekyll" /><category term="layout" /><category term="link" /><category term="Love" /><category term="markup" /><category term="Mothership" /><category term="Must Read" /><category term="Nailed It" /><category term="Pictures" /><category term="Post Formats" /><category term="quote" /><category term="standard" /><category term="Success" /><category term="Swagger" /><category term="Tags" /><category term="template" /><category term="title" /><category term="twitter" /><category term="Unseen" /><category term="video" /><category term="YouTube" /><summary type="html"><![CDATA[This post has many tags.]]></summary></entry></feed>